datasource db {
  provider = "sqlite"
  url      = env("DATABASE_URL")
}

generator client {
  provider = "prisma-client-js"
}

enum ProjectType {
  gitcms
  papertrail
  workspace
}

enum ProjectScope {
  private
  org
  public
}

enum ProjectStatus {
  draft
  published
}

model Project {
  id        String  @id @default(cuid()) @map("id")
  name      String  @default("Untitled") @map("name")
  slug      String? @unique @map("slug")
  desc      String? @map("desc")
  publicUrl String? @map("public_url")

  type   ProjectType   @default(gitcms) @map("type")
  scope  ProjectScope  @default(private) @map("scope")
  status ProjectStatus @default(draft) @map("status")

  // 1:1 subtypes
  gitcms     ProjectGitCMS?
  papertrail ProjectPaperTrail?
  workspace  ProjectWorkspace?

  ownerId String? @map("user_id")
  owner   User?   @relation("Owner", fields: [ownerId], references: [id], onDelete: SetNull)

  admins       User[] @relation("ProjectAdmins")
  editors      User[] @relation("ProjectEditors")
  contributors User[] @relation("ProjectContributors")

  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  @@index([id])
  @@index([ownerId])
  @@index([createdAt])
  @@map("projects")
}

enum GitProvider {
  github
  gitlab
  bitbucket
  gitea
  other
}

enum AuthType {
  ssh
  https
  token
  userpass
}

// CMS Git project-specific fields
model ProjectGitCMS {
  projectId String  @id @map("project_id")
  project   Project @relation(fields: [projectId], references: [id], onDelete: Cascade)

  repoUrl       String       @map("repo_url")
  defaultBranch String       @default("main") @map("default_branch")
  contentDir    String?      @map("content_dir")
  lastCommit    String?      @map("last_commit")
  provider      GitProvider? @default(github) @map("provider")
  authType      AuthType?    @default(ssh) @map("auth_type")
  authSecret    String?      @map("auth_secret")

  gitUserName  String? @map("git_user_name")
  gitUserEmail String? @map("git_user_email")

  postMetas PostMeta[]
}

model PostMeta {
  id        String    @id @default(cuid())
  path      String
  title     String?
  excerpt   String?
  pubDate   DateTime?
  draft     Boolean?  @default(true)
  tags      String?
  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt
  deletedAt DateTime?

  gitcmsId String?        @map("gitcms_id")
  gitcms   ProjectGitCMS? @relation(fields: [gitcmsId], references: [projectId], onDelete: Cascade)

  @@unique([gitcmsId, path])
  @@index([gitcmsId])
  @@map("post_meta")
}

// PaperTrail project-specific fields
model ProjectPaperTrail {
  projectId String  @id @map("project_id")
  project   Project @relation(fields: [projectId], references: [id], onDelete: Cascade)

  schemaVersion Int @default(1) @map("schema_version")

  nodes PaperTrailNode[]
  edges PaperTrailEdge[]
}

model PaperTrailNode {
  id      String @id @default(cuid()) @map("id")
  boardId String @map("board_id")
  type    String @map("type")
  x       Int    @map("x")
  y       Int    @map("y")
  w       Int?   @map("w")
  h       Int?   @map("h")

  // content fields expected by server.mjs
  title    String? @map("title")
  text     String? @map("text")
  html     String? @map("html")
  descHtml String? @map("desc_html")
  linkUrl  String? @map("link_url")
  imageUrl String? @map("image_url")

  board ProjectPaperTrail   @relation(fields: [boardId], references: [projectId], onDelete: Cascade)
  tags  PaperTrailNodeTag[]

  @@index([boardId])
  @@index([boardId, type])
  @@map("nodes")
}

model PaperTrailEdge {
  id       String  @id @default(cuid()) @map("id")
  boardId  String  @map("board_id")
  sourceId String  @map("source_id")
  targetId String  @map("target_id")
  label    String? @map("label")
  dashed   Boolean @default(false) @map("dashed")
  color    String? @map("color")

  board ProjectPaperTrail @relation(fields: [boardId], references: [projectId], onDelete: Cascade)

  @@index([boardId])
  @@index([boardId, sourceId])
  @@index([boardId, targetId])
  @@map("edges")
}

model PaperTrailTag {
  id    String              @id @default(cuid()) @map("id")
  name  String              @unique @map("name")
  nodes PaperTrailNodeTag[]

  @@map("tags")
}

model PaperTrailNodeTag {
  nodeId String @map("node_id")
  tagId  String @map("tag_id")

  node PaperTrailNode @relation(fields: [nodeId], references: [id], onDelete: Cascade)
  tag  PaperTrailTag  @relation(fields: [tagId], references: [id], onDelete: Cascade)

  @@id([nodeId, tagId])
  @@index([nodeId])
  @@index([tagId])
  @@map("node_tags")
}

// Workspace project-specific fields
model ProjectWorkspace {
  projectId String  @id @map("project_id")
  project   Project @relation(fields: [projectId], references: [id], onDelete: Cascade)
}

enum UserStatus {
  invited
  active
  suspended
}

model User {
  id              String    @id @default(cuid()) @map("id")
  email           String    @unique @map("email")
  emailVerifiedAt DateTime? @map("email_verified_at")
  displayName     String?   @map("display_name")
  username        String    @unique @map("username")
  role            Int       @default(9) @map("role") // 0=owner, 1=admin, 2=editor, 3=viewer, 4=contributor, ..., 9=guest
  passwordHash    String?   @map("password_hash") // allow empty until user sets it

  sessions            Session[]
  verificationTokens  VerificationToken[]  @relation("UserToVerificationTokens")
  passwordResetTokens PasswordResetToken[] @relation("UserToPasswordResetTokens")

  ownedProjects Project[] @relation("Owner")
  adminOf       Project[] @relation("ProjectAdmins")
  editorOf      Project[] @relation("ProjectEditors")
  contributorOf Project[] @relation("ProjectContributors")

  status    UserStatus @default(invited) @map("status")
  createdAt DateTime   @default(now()) @map("created_at")
  updatedAt DateTime   @updatedAt @map("updated_at")

  @@index([createdAt])
  @@index([emailVerifiedAt])
  @@map("users")
}

model Session {
  id        String   @id @default(cuid()) @map("id")
  userId    String   @map("user_id")
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  token     String   @unique @map("token")
  ipHash    String?  @map("ip_hash")
  userAgent String?  @map("user_agent")
  expiresAt DateTime @map("expires_at")
  createdAt DateTime @default(now()) @map("created_at")

  @@index([userId])
  @@index([token])
  @@index([expiresAt])
  @@map("sessions")
}

model VerificationToken {
  id        String   @id @default(cuid()) @map("id")
  userId    String   @map("user_id")
  user      User     @relation(name: "UserToVerificationTokens", fields: [userId], references: [id], onDelete: Cascade)
  token     String   @unique @map("token")
  purpose   String   @map("purpose") // 'email-verify'
  expiresAt DateTime @map("expires_at")
  createdAt DateTime @default(now()) @map("created_at")

  @@index([userId])
  @@index([token])
  @@index([expiresAt])
  @@map("verification_tokens")
}

model PasswordResetToken {
  id        String   @id @default(cuid()) @map("id")
  userId    String   @map("user_id")
  user      User     @relation(name: "UserToPasswordResetTokens", fields: [userId], references: [id], onDelete: Cascade)
  token     String   @unique @map("token")
  expiresAt DateTime @map("expires_at")
  createdAt DateTime @default(now()) @map("created_at")

  @@index([userId])
  @@index([token])
  @@index([expiresAt])
  @@map("password_reset_tokens")
}
