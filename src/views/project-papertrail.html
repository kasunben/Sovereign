<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>PaperTrail — map your evidence, follow the story.</title>
    <link rel="icon" type="image/svg+xml" href="/assets/favicon.svg" />

    <!-- Primary SEO -->
    <meta name="application-name" content="PaperTrail" />
    <meta
      name="description"
      content="PaperTrail is a lightweight evidence-mapping app. Create text, image, and link nodes, connect them, auto-layout, and import/export boards."
    />
    <meta
      name="keywords"
      content="evidence board, investigation, graph, nodes, links, mind map, research, PaperTrail"
    />
    <meta name="robots" content="index,follow" />
    <link rel="canonical" href="/" />
    <meta name="theme-color" content="#ffffff" />

    <!-- Open Graph / Facebook -->
    <meta property="og:site_name" content="PaperTrail" />
    <meta property="og:type" content="website" />
    <meta
      property="og:title"
      content="PaperTrail — map your evidence, follow the story."
    />
    <meta
      property="og:description"
      content="PaperTrail is a lightweight evidence-mapping app. Create text, image, and link nodes, connect them, auto-layout, and import/export boards."
    />
    <meta property="og:url" content="/" />
    <meta property="og:image" content="/assets/og-image.png" />
    <meta property="og:image:type" content="image/png" />
    <meta property="og:image:width" content="1200" />
    <meta property="og:image:height" content="630" />

    <!-- Twitter -->
    <meta name="twitter:card" content="summary_large_image" />
    <meta
      name="twitter:title"
      content="PaperTrail — map your evidence, follow the story."
    />
    <meta
      name="twitter:description"
      content="PaperTrail is a lightweight evidence-mapping app. Create text, image, and link nodes, connect them, auto-layout, and import/export boards."
    />
    <meta name="twitter:image" content="/assets/og-image.png" />
    <link rel="stylesheet" href="/css/global.css" />
    <link rel="stylesheet" href="/css/pages/papertrail.css" />
  </head>

  <body class="page page-papertrail">
    {{> sidebar}}
    <main class="page__wrap page__wrap--fullwidth">
      <div class="papertrail-header" role="toolbar">
        <div class="papertrail-header__title">
          <a class="papertrail-header__brand" href="/">PaperTrail</a>
          <div class="papertrail-header__tagline">
            map your evidence, follow the story.
          </div>
          <div
            class="papertrail-header__board-name"
            id="boardName"
            contenteditable="true"
            data-placeholder="Untitled Board"
          ></div>
        </div>
        <button
          id="addText"
          class="papertrail-header__btn papertrail-header__btn--icon"
          title="Add text"
        >
          <svg viewBox="0 0 24 24" aria-hidden="true">
            <rect x="4" y="3" width="16" height="18" rx="2" ry="2" />
            <line x1="8" y1="9" x2="16" y2="9" />
            <line x1="8" y1="13" x2="16" y2="13" />
            <line x1="8" y1="17" x2="14" y2="17" />
          </svg>
        </button>
        <button
          id="addImage"
          class="papertrail-header__btn papertrail-header__btn--icon"
          title="Add image (URL)"
        >
          <svg viewBox="0 0 24 24" aria-hidden="true">
            <rect x="3" y="5" width="18" height="14" rx="2" />
            <path d="M7 15l3-3 3 3 4-4 3 3" />
            <circle cx="9" cy="9" r="1.5" />
          </svg>
        </button>
        <button
          id="uploadImage"
          class="papertrail-header__btn papertrail-header__btn--icon"
          title="Upload image"
        >
          <svg viewBox="0 0 24 24" aria-hidden="true">
            <path d="M12 15V5" />
            <path d="M8 9l4-4 4 4" />
            <path d="M4 19h16" />
          </svg>
        </button>
        <input
          id="fileInput"
          type="file"
          accept="image/*"
          style="display: none"
        />
        <button
          id="addLink"
          class="papertrail-header__btn papertrail-header__btn--icon"
          title="Add link"
        >
          <svg viewBox="0 0 24 24" aria-hidden="true">
            <path d="M10 14l-2 2a4 4 0 0 1-6-6l2-2" />
            <path d="M14 10l2-2a4 4 0 0 1 6 6l-2 2" />
            <path d="M8 12l8-8" opacity="0.0" />
          </svg>
        </button>
        <button
          id="connect"
          class="papertrail-header__btn papertrail-header__btn--icon"
          title="Connect nodes (C)"
        >
          <svg viewBox="0 0 24 24" aria-hidden="true">
            <circle cx="6" cy="12" r="2" />
            <circle cx="18" cy="6" r="2" />
            <circle cx="18" cy="18" r="2" />
            <path d="M8 12h6" />
            <path d="M12 12L17 7" />
            <path d="M12 12l5 5" />
          </svg>
        </button>
        <div class="papertrail-header__search-wrap">
          <input
            id="search"
            class="papertrail-header__search"
            type="search"
            placeholder="Search… (use #tag)"
          />
          <button id="clearSearch" title="Clear search">✕</button>
        </div>
        <div class="toolbar__spacer"></div>
        <button
          id="autoLayout"
          class="papertrail-header__btn papertrail-header__btn--icon"
          title="Auto layout"
        >
          <svg viewBox="0 0 24 24" aria-hidden="true">
            <rect x="4" y="4" width="6" height="6" />
            <rect x="14" y="4" width="6" height="6" />
            <rect x="4" y="14" width="6" height="6" />
            <rect x="14" y="14" width="6" height="6" />
          </svg>
        </button>
        <button
          id="export"
          class="papertrail-header__btn papertrail-header__btn--icon"
          title="Export board"
        >
          <svg viewBox="0 0 24 24" aria-hidden="true">
            <path d="M12 5v10" />
            <path d="M8 9l4-4 4 4" />
            <path d="M4 19h16" />
          </svg>
        </button>
        <button
          id="importBtn"
          class="papertrail-header__btn papertrail-header__btn--icon"
          title="Import board"
        >
          <svg viewBox="0 0 24 24" aria-hidden="true">
            <path d="M12 19V9" />
            <path d="M8 15l4 4 4-4" />
            <path d="M4 5h16" />
          </svg>
        </button>
        <input
          id="importFile"
          type="file"
          accept="application/zip,application/x-zip-compressed,.zip,application/json"
          style="display: none"
        />
        {{#if is_owner}}
        <button
          id="save"
          class="papertrail-header__btn papertrail-header__btn--icon"
          disabled
          title="Save"
        >
          <svg viewBox="0 0 24 24" aria-hidden="true">
            <rect x="4" y="4" width="16" height="16" rx="2" />
            <rect x="8" y="4" width="8" height="6" />
            <rect x="9" y="14" width="6" height="6" />
          </svg>
        </button>
        {{/if}}
        <button
          id="reset"
          class="papertrail-header__btn papertrail-header__btn--icon"
          title="Reset board"
        >
          <svg viewBox="0 0 24 24" aria-hidden="true">
            <path d="M3 12a9 9 0 1 0 3-6" />
            <path d="M3 4v6h6" />
          </svg>
        </button>
        <button
          id="infoBtn"
          class="papertrail-header__btn papertrail-header__btn--icon"
          title="About / Info"
        >
          <svg viewBox="0 0 24 24" aria-hidden="true">
            <circle cx="12" cy="12" r="10" />
            <circle cx="12" cy="8" r="1.4" />
            <path d="M12 11v5" stroke-linecap="round" />
          </svg>
        </button>
        {{#if show_settings}}
        <button
          id="settingsBtn"
          class="papertrail-header__btn papertrail-header__btn--icon"
          title="Board settings"
        >
          <svg viewBox="0 0 24 24" aria-hidden="true">
            <circle cx="12" cy="12" r="3" />
            <path
              d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 1 1-2.83 2.83l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 1 1-4 0v-.09a1.65 1.65 0 0 0-1-1.51 1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 1 1-2.83-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 1 1 0-4h.09a1.65 1.65 0 0 0 1.51-1 1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 1 1 2.83-2.83l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1-1.51V3a2 2 0 1 1 4 0v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 1 1 2.83 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82V9c0 .66.26 1.3.73 1.77.47.47 1.11.73 1.77.73H21a2 2 0 1 1 0 4h-.09a1.65 1.65 0 0 0-1.51 1z"
            />
          </svg>
        </button>
        {{/if}}
        <div style="width: 32px">
          {{> userbar hide_user_name=true show_user_menu=true overrides="top-28"}}
        </div>
      </div>
      <div class="papertrail-board" id="board">
        <div id="boardSizer"></div>
        <svg id="edges"></svg>
      </div>
      <div id="ctxMenu" class="context-menu"></div>
      <div class="statusbar">
        <span id="status" class="statusbar__text"></span>
        <span class="statusbar__hint" id="modeHint"
          >💡 Mode: Select/Move. Press C to toggle connect mode.</span
        >
      </div>
      <div
        id="aboutModal"
        class="modal__backdrop"
        role="dialog"
        aria-modal="true"
        aria-labelledby="aboutTitle"
      >
        <div class="modal">
          <header class="modal__header">
            <h3 id="aboutTitle" class="modal__title">
              PaperTrail — map your evidence, follow the story
            </h3>
            <button
              type="button"
              id="aboutClose"
              class="modal__close"
              aria-label="Close"
            >
              ✕
            </button>
          </header>
          <div class="modal__body">
            <p>
              <em>PaperTrail</em> is a lightweight visual evidence board for
              organizing ideas, documents, images, and links. It lets you pin
              down pieces of information, connect them freely, and uncover
              patterns. Whether you’re researching, investigating, or just
              making sense of complex projects, PaperTrail helps you create a
              clear trail of evidence you can return to and share.
            </p>
            <p>
              At this stage, PaperTrail is designed as a single-user,
              single-workspace app. That means there is only one active board
              available at a time. Features such as real-time collaboration,
              multi-user access, or simultaneous editing are not yet supported.
            </p>
            <p>
              If you want to manage multiple boards or workspaces, you can still
              do so manually using the Import/Export features:
            </p>
            <ul>
              <li>Export your current board as a .zip file to save it.</li>
              <li>
                Import a previously exported board to continue working on it.
              </li>
              <li>
                You are responsible for organizing these exported files if you
                wish to maintain multiple workspaces.
              </li>
            </ul>
            <p>
              This setup is lightweight and simple, making it ideal for solo
              use, prototyping, or testing out ideas. Future versions of
              PaperTrail may add multi-board support and collaboration features.
            </p>
            <div class="kv">
              <div>App version</div>
              <div id="aboutAppVersion">—</div>
              <div>Schema version</div>
              <div id="aboutSchemaVersion">—</div>
              <div>Current board</div>
              <div id="aboutBoardName">—</div>
            </div>
          </div>
        </div>
      </div>
      <div
        id="settingsModal"
        class="modal__backdrop"
        role="dialog"
        aria-modal="true"
        aria-labelledby="settingsTitle"
      >
        <div class="modal">
          <header class="modal__header">
            <h3 id="settingsTitle" class="modal__title">Board settings</h3>
            <button
              type="button"
              id="settingsClose"
              class="modal__close"
              aria-label="Close"
            >
              ✕
            </button>
          </header>
          <div class="modal__body">
            <p
              id="settingsNotice"
              style="
                display: none;
                margin: 10px 0px 0px;
                color: #b45309;
                background: #fff7ed;
                border: 1px solid #fde68a;
                padding: 8px 10px;
                border-radius: 8px;
              "
            >
              You can view settings on public boards, but only the owner can
              make changes.
            </p>
            <div
              style="
                display: grid;
                grid-template-columns: 140px 1fr;
                gap: 10px;
                align-items: center;
                margin-top: 15px;
              "
            >
              <label for="titleInput">Title</label>
              <input id="titleInput" type="text" />

              <label for="visibilitySelect">Visibility</label>
              <select id="visibilitySelect">
                <option value="public">Public</option>
                <option value="private">Private</option>
              </select>

              <label for="statusSelect">Status</label>
              <select id="statusSelect">
                <option value="draft">Draft</option>
                <option value="published">Published</option>
              </select>
            </div>

            <div
              style="
                display: flex;
                gap: 10px;
                justify-content: flex-end;
                margin-top: 16px;
              "
            >
              <button id="saveMetaBtn">Save changes</button>
            </div>
            {{#if is_owner}}
            <details style="margin-top: 10px">
              <summary><strong>Danger zone</strong></summary>
              <div
                style="
                  border: 1px solid #ccc;
                  margin-top: 5px;
                  padding: 10px;
                  border-radius: 0.3rem;
                "
              >
                <span style="color: #b91c1c">
                  Deleting this board is permanent. This removes nodes, edges,
                  and uploads.
                </span>
                <div
                  style="
                    display: flex;
                    gap: 10px;
                    align-items: center;
                    margin-top: 5px;
                  "
                >
                  <input
                    id="confirmIdInput"
                    type="text"
                    placeholder="Type: {{board_id}}"
                  />
                  <button id="deleteBoardBtn">Delete</button>
                </div>
              </div>
            </details>
            {{/if}}
          </div>
        </div>
      </div>
    </main>
    <script>
      // Binding for dynamic values from server
      // (injected by server-side templating)
      window.__globals = {
        appVersion: "{{app_version}}",
        schemaVersion: "{{schema_version}}",
        boardId: "{{board_id}}",
        boardTitle: "{{board_title}}",
        boardVisibility: "{{board_visibility}}",
        boardStatus: "{{board_status}}",
        isOwner: "{{is_owner}}",
      };

      // --- App State ---
      const $ = (sel) => document.querySelector(sel);
      const toolbarEl = document.querySelector(".papertrail-header");
      const boardEl = $("#board");
      const edgesSvg = $("#edges");
      const statusEl = $("#status");
      let saveBtn = document.getElementById("save");
      const exportBtn = document.getElementById("export");
      const importBtn = document.getElementById("importBtn");
      const importFile = document.getElementById("importFile");
      const searchInput = document.getElementById("search");
      const infoBtn = document.getElementById("infoBtn");
      const aboutModal = document.getElementById("aboutModal");
      const aboutClose = document.getElementById("aboutClose");
      const isOwner = String(window.__globals.isOwner) === "true";
      let lastSavedJSON = null;

      // --- Ensure DOM positions/sizes are synced to the model prior to save
      function syncDomToModel() {
        for (const n of board.nodes) {
          const el = document.getElementById(n.id);
          if (!el) continue;
          const left = Number.parseFloat(el.style.left);
          const top = Number.parseFloat(el.style.top);
          n.x = Number.isFinite(left) ? left : el.offsetLeft || n.x || 0;
          n.y = Number.isFinite(top) ? top : el.offsetTop || n.y || 0;
          // Persist measured size so edges/auto-layout remain consistent after reload
          n.w = Math.trunc(el.offsetWidth || n.w || 0) || undefined;
          n.h = Math.trunc(el.offsetHeight || n.h || 0) || undefined;
        }
      }

      // Rebind the Save button to guarantee our latest handler and avoid duplicate listeners
      function wireSaveButton() {
        if (!saveBtn) return;
        const oldBtn = document.getElementById("save");
        const newBtn = oldBtn.cloneNode(true); // drops prior listeners
        oldBtn.parentNode.replaceChild(newBtn, oldBtn);
        saveBtn = newBtn;

        newBtn.addEventListener("click", async () => {
          try {
            newBtn.disabled = true;
            // Always sync the latest DOM position/size state before snapshot + POST
            syncDomToModel();
            const payload = { ...board, id: window.__globals.boardId };
            const resp = await fetch(
              `/api/board/${encodeURIComponent(window.__globals.boardId)}`,
              {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify(payload),
              },
            );
            const data = await resp.json().catch(() => ({}));
            if (!resp.ok)
              throw new Error(data && data.error ? data.error : "Save failed");
            // Update local model with canonical server state
            board = data;
            lastSavedJSON = computeSnapshot();
            showStatus("Saved.", { ttl: 1600 });
            render();
            updateSaveButton();
          } catch (e) {
            showStatus(e && e.message ? e.message : "Save failed", {
              sticky: true,
            });
          } finally {
            updateSaveButton();
          }
        });
      }

      // Ghost edge state
      let ghostPath = null; // SVGPathElement
      let lastMouse = { x: 0, y: 0 };

      function ensureGhostPath() {
        if (!ghostPath) {
          ghostPath = document.createElementNS(
            "http://www.w3.org/2000/svg",
            "path",
          );
          ghostPath.setAttribute("class", "edge edge--ghost");
          edgesSvg.appendChild(ghostPath);
        } else if (!edgesSvg.contains(ghostPath)) {
          edgesSvg.appendChild(ghostPath);
        }
      }
      function hideGhost() {
        if (ghostPath) ghostPath.setAttribute("d", "");
      }
      function boardPointFromClient(ev) {
        const rect = boardEl.getBoundingClientRect();
        return {
          x: boardEl.scrollLeft + (ev.clientX - rect.left),
          y: boardEl.scrollTop + (ev.clientY - rect.top),
        };
      }
      function renderGhostEdge() {
        if (!connectMode || !connectFromId) {
          hideGhost();
          return;
        }
        const src = board.nodes.find((n) => n.id === connectFromId);
        if (!src) {
          hideGhost();
          return;
        }
        // Use the same smooth cubic logic as permanent edges
        const mx = lastMouse.x,
          my = lastMouse.y;
        const a1 = anchorPoint(src, mx, my);
        const a2 = mouseAnchor(src, mx, my);
        ensureGhostPath();
        ghostPath.setAttribute("d", smoothCubic(a1, a2));
      }

      function adjustBoardHeight() {
        const tb = toolbarEl ? toolbarEl.offsetHeight : 0;
        // 24px = status bar height
        boardEl.style.height = `calc(100vh - ${tb}px - 24px)`;
        updateBoardExtent();
      }
      window.addEventListener("resize", adjustBoardHeight);

      boardEl.addEventListener("mousemove", (ev) => {
        lastMouse = boardPointFromClient(ev);
        if (connectMode && connectFromId) renderGhostEdge();
      });
      // Also update when moving over the SVG layer (useful when pointer leaves node area)
      edgesSvg.addEventListener("mousemove", (ev) => {
        lastMouse = boardPointFromClient(ev);
        if (connectMode && connectFromId) renderGhostEdge();
      });

      // Unified status & mode controller
      const ui = {
        connectMode: false,
        status: { text: "", timer: null, sticky: false },
      };
      function renderStatusBar() {
        const modeText = ui.connectMode
          ? "💡 Mode: Connect"
          : "💡 Mode: Select/Move (press C to connect)";
        document.getElementById("modeHint").textContent = modeText;
        statusEl.textContent = ui.status.text || "";
      }
      function setConnectMode(on) {
        ui.connectMode = !!on;
        document.body.classList.toggle("connect-mode", ui.connectMode);
        const connectBtn = document.getElementById("connect");
        connectBtn.classList.toggle("toolbar__btn--active", ui.connectMode);

        // Disable/enable other toolbar controls
        document.querySelectorAll(".toolbar button").forEach((btn) => {
          if (btn.id === "connect") return;
          btn.disabled = ui.connectMode;
        });

        renderStatusBar();
      }

      // Show a transient status message; use {sticky:true} to persist until changed
      function showStatus(msg, opts = {}) {
        const { sticky = false, ttl = 2200 } = opts;
        // Avoid flicker: ignore if message unchanged
        if (ui.status.text === msg && ui.status.sticky === sticky) return;
        ui.status.text = msg;
        ui.status.sticky = sticky;
        statusEl.textContent = ui.status.text;
        if (ui.status.timer) {
          clearTimeout(ui.status.timer);
          ui.status.timer = null;
        }
        if (!sticky) {
          ui.status.timer = setTimeout(() => {
            ui.status.text = "";
            ui.status.sticky = false;
            renderStatusBar();
          }, ttl);
        }
      }

      // Back-compat wrappers so existing calls keep working
      function setStatus(msg) {
        showStatus(msg);
      }

      const boardNameEl = document.getElementById("boardName");

      // Keep single-line feel: prevent Enter/Return from inserting new lines
      boardNameEl.addEventListener("keydown", (e) => {
        if (e.key === "Enter") {
          e.preventDefault();
          boardNameEl.blur();
        }
      });

      // Update model on input and enable Save
      boardNameEl.addEventListener("input", () => {
        board.title = (boardNameEl.textContent || "").trim();
        markDirty();
      });

      // On blur, ensure a non-empty title for display (model can be empty if desired)
      boardNameEl.addEventListener("blur", () => {
        if (!boardNameEl.textContent || !boardNameEl.textContent.trim()) {
          boardNameEl.textContent = "Untitled Board";
        }
      });

      function isTypingTarget(el) {
        if (!el) return false;
        if (el.isContentEditable) return true;
        const tag = (el.tagName || "").toUpperCase();
        return tag === "INPUT" || tag === "TEXTAREA" || tag === "SELECT";
      }

      function stableBoardSnapshot(b) {
        // Create a deterministic snapshot that ignores volatile fields (like updatedAt)
        // and normalizes numeric values so tiny float jitter doesn't flip the Save button.
        return {
          id: b.id,
          title: b.title || "",
          visibility: b.visibility || "public",
          // Normalize nodes and only include fields that affect persistence
          nodes: (b.nodes || []).map((n) => ({
            id: n.id,
            type: n.type,
            x: Math.round(n.x || 0),
            y: Math.round(n.y || 0),
            w: Number.isFinite(n.w) ? Math.round(n.w) : undefined,
            h: Number.isFinite(n.h) ? Math.round(n.h) : undefined,
            data: n.data || {},
          })),
          // Normalize edges similarly
          edges: (b.edges || []).map((e) => ({
            id: e.id,
            sourceId: e.sourceId,
            targetId: e.targetId,
            label: e.label || undefined,
            dashed: !!e.dashed,
            color: e.color || undefined,
          })),
          createdAt: b.createdAt || undefined,
          // NOTE: updatedAt is intentionally excluded from snapshot comparison
        };
      }
      function computeSnapshot() {
        return JSON.stringify(stableBoardSnapshot(board));
      }
      function updateSaveButton() {
        if (!saveBtn) return;

        const snap = computeSnapshot();
        // On first run, capture a clean baseline so Save starts disabled,
        // and subsequent changes correctly enable the button.
        if (lastSavedJSON === null) {
          lastSavedJSON = snap;
          saveBtn.disabled = true;
          return;
        }
        saveBtn.disabled = snap === lastSavedJSON;
      }
      function markDirty() {
        // Record mutation time (not part of snapshot equivalence)
        try {
          board.updatedAt = new Date().toISOString();
        } catch (_) {}
        // Re-evaluate against the last saved snapshot so moving a node back disables Save
        updateSaveButton();
      }
      const ctxMenu = document.getElementById("ctxMenu");
      let ctxTarget = null; // { type: 'node'|'edge', id: string }

      function showContextMenu(x, y, target) {
        ctxTarget = target; // { type, id }
        const menu = ctxMenu;

        // Build menu dynamically based on target type
        if (ctxTarget && ctxTarget.type === "edge") {
          menu.innerHTML = `
            <button class="context-menu__item" data-action="label">Edit label</button>
            <button class="context-menu__item" data-action="dashed">Toggle dashed</button>
            <button class="context-menu__item" data-action="color">Set color…</button>
            <button class="context-menu__item" data-action="delete">Delete</button>
          `;
        } else {
          const node = board.nodes.find((n) => n.id === target.id);
          if (!node) {
            menu.innerHTML = "";
          } else if (node.type === "link") {
            const canEditText = !!(
              node.data &&
              typeof node.data.descHtml === "string" &&
              node.data.descHtml.trim().length
            );
            menu.innerHTML = `
      <button class="context-menu__item" data-action="edit-link-url">Edit link URL…</button>
      ${
        canEditText
          ? '<button class="context-menu__item" data-action="edit-text">Edit text…</button>'
          : ""
      }
      <button class="context-menu__item" data-action="delete">Delete</button>
    `;
          } else if (node.type === "image") {
            const canEditText = !!(
              node.data &&
              typeof node.data.descHtml === "string" &&
              node.data.descHtml.trim().length
            );
            menu.innerHTML = `
      ${
        canEditText
          ? '<button class="context-menu__item" data-action="edit-text">Edit text…</button>'
          : ""
      }
      <button class="context-menu__item" data-action="delete">Delete</button>
    `;
          } else if (node.type === "text") {
            menu.innerHTML = `
      <button class="context-menu__item" data-action="edit-text">Edit text…</button>
      <button class="context-menu__item" data-action="delete">Delete</button>
    `;
          } else {
            menu.innerHTML = `
      <button class="context-menu__item" data-action="delete">Delete</button>
    `;
          }
        }

        menu.style.display = "block";
        // constrain within window
        const mw = menu.offsetWidth || 160;
        const mh = menu.offsetHeight || 44;
        const vw = window.innerWidth;
        const vh = window.innerHeight;
        let px = x,
          py = y;
        if (px + mw > vw) px = vw - mw - 8;
        if (py + mh > vh) py = vh - mh - 8;
        menu.style.left = px + "px";
        menu.style.top = py + "px";
      }
      function hideContextMenu() {
        ctxMenu.style.display = "none";
        ctxTarget = null;
      }

      // clicking elsewhere hides menu
      document.addEventListener("mousedown", (ev) => {
        if (ctxMenu.style.display === "block") {
          const within = ctxMenu.contains(ev.target);
          if (!within) hideContextMenu();
        }
      });

      // Esc hides menu
      document.addEventListener("keydown", (ev) => {
        if (ev.key === "Escape") hideContextMenu();
      });

      // Context menu actions (delegated)
      ctxMenu.addEventListener("click", (ev) => {
        const btn = ev.target.closest("button");
        if (!btn) return;
        const action = btn.getAttribute("data-action");
        if (!ctxTarget) {
          hideContextMenu();
          return;
        }

        if (ctxTarget.type === "node") {
          const node = board.nodes.find((n) => n.id === ctxTarget.id);
          if (!node) {
            hideContextMenu();
            return;
          }

          if (action === "edit-text") {
            const nodeEl = document.getElementById(node.id);
            if (nodeEl) {
              const rich = nodeEl.querySelector(".rich");
              if (rich) {
                // enter edit mode
                rich.setAttribute("contenteditable", "true");
                nodeEl.classList.add("node--editing");
                setTimeout(() => {
                  try {
                    placeCaretAtEnd(rich);
                  } catch (_) {}
                  rich.focus();
                }, 0);
              }
            }
            hideContextMenu();
            return;
          }

          if (action === "delete") {
            selectedNodeId = ctxTarget.id;
            selectedEdgeId = null;
            hideContextMenu();
            removeSelection();
            return;
          }

          if (action === "edit-link-url" && node.type === "link") {
            const val = prompt("Link URL:", node.data.linkUrl || "https://");
            if (val !== null) {
              const url = (val || "").trim();
              if (url) {
                node.data.linkUrl = url;
                // Invalidate previous preview so it refetches
                delete node.data.preview;
                hideContextMenu();
                markDirty();
                renderNode(node);
                renderEdges();
              }
            }
            return;
          }
          hideContextMenu();
          return;
        }

        // Edge actions
        const edge = board.edges.find((e) => e.id === ctxTarget.id);
        if (!edge) {
          hideContextMenu();
          return;
        }

        if (action === "delete") {
          selectedEdgeId = edge.id;
          selectedNodeId = null;
          hideContextMenu();
          removeSelection();
        } else if (action === "label") {
          const val = prompt("Edge label:", edge.label || "");
          if (val !== null) {
            edge.label = val.trim();
            hideContextMenu();
            markDirty();
            renderEdges();
          }
        } else if (action === "dashed") {
          edge.dashed = !edge.dashed;
          hideContextMenu();
          markDirty();
          renderEdges();
        } else if (action === "color") {
          const val = prompt(
            "Stroke color (e.g. #f87171 or red). Leave blank to reset:",
            edge.color || "",
          );
          if (val === null) return;
          const v = val.trim();
          if (v === "") delete edge.color;
          else edge.color = v;
          hideContextMenu();
          markDirty();
          renderEdges();
        }
      });

      let board = {
        id: "board-1",
        title: "My Evidence Board",
        nodes: [],
        edges: [],
        createdAt: new Date().toISOString(),
        updatedAt: new Date().toISOString(),
      };

      // Initialize board name display from default board.title
      boardNameEl.textContent = board.title || "";
      // Establish initial clean snapshot so Save enables on changes
      updateSaveButton();
      wireSaveButton();

      (async function loadInitialBoard() {
        // try {
        //   const resp = await fetch(
        //     `/api/board/${encodeURIComponent(window.__globals.boardId)}`
        //   );
        //   if (!resp.ok) throw new Error("not found");
        //   const board = await resp.json();
        //   boardNameEl.textContent = board.title;
        //   lastSavedJSON = computeSnapshot();
        //   render();
        //   updateSaveButton();
        //   wireSaveButton();
        // } catch (e) {
        //   console.error("Failed to load board:", window.__globals.boardId, e);
        //   // window.location.href = "/404.html";
        // }
      })();

      let selectedNodeId = null;
      let selectedEdgeId = null;
      let connectMode = false;
      let connectFromId = null;

      const genId = (p = "id") =>
        p + "-" + Math.random().toString(36).slice(2, 8);

      function addNode(type, at = { x: 100, y: 100 }, payload = {}) {
        const id = genId("n");
        const base = {
          id,
          type,
          x: at.x,
          y: at.y,
          w: 240,
          h: undefined,
          data: {},
        };
        if (type === "text") {
          base.data.text = payload.text ?? "New note...";
          base.data.html = escapeHtml(base.data.text);
          base.data.title = payload.title ?? "Text";
        } else if (type === "image") {
          // Ask for URL if not provided; cancel = no node
          let url = payload.imageUrl;
          if (url === undefined) {
            url = prompt("Image URL?", "");
          }
          if (url === null) return null; // user cancelled
          url = (url || "").trim();
          if (!url) return null; // empty -> abort
          base.data.imageUrl = url;
          base.data.title = payload.title ?? "Image";
          base.data.descHtml = payload.descHtml ?? ""; // optional description (rich)
        } else if (type === "link") {
          // Ask for URL if not provided; cancel = no node
          let url = payload.linkUrl;
          if (url === undefined) {
            url = prompt("Link URL?", "https://");
          }
          if (url === null) return null; // user cancelled
          url = (url || "").trim();
          if (!url) return null; // empty -> abort
          base.data.linkUrl = url;
          base.data.title = payload.title ?? "Link";
          base.data.descHtml = payload.descHtml ?? ""; // optional description (rich)
        }
        board.nodes.push(base);
        markDirty();
        render();
        return base;
      }

      function addEdge(sourceId, targetId) {
        if (!sourceId || !targetId || sourceId === targetId) return;
        const already = board.edges.find(
          (e) => e.sourceId === sourceId && e.targetId === targetId,
        );
        if (already) return;
        board.edges.push({ id: genId("e"), sourceId, targetId });
        markDirty();
        renderEdges();
      }

      function removeSelection() {
        if (selectedNodeId) {
          board.edges = board.edges.filter(
            (e) =>
              e.sourceId !== selectedNodeId && e.targetId !== selectedNodeId,
          );
          board.nodes = board.nodes.filter((n) => n.id !== selectedNodeId);
          setStatus("Node deleted.");
          selectedNodeId = null;
        } else if (selectedEdgeId) {
          board.edges = board.edges.filter((e) => e.id !== selectedEdgeId);
          setStatus("Edge deleted.");
          selectedEdgeId = null;
        }
        markDirty();
        render();
      }

      function nodeBounds(n) {
        const el = document.getElementById(n.id);
        if (el) {
          // Use live DOM position to prevent model/view drift after save
          const left =
            Number.parseFloat(el.style.left) || el.offsetLeft || n.x || 0;
          const top =
            Number.parseFloat(el.style.top) || el.offsetTop || n.y || 0;
          const w = n.w || el.offsetWidth || 200;
          const h = n.h || el.offsetHeight || 80;
          return { x: left, y: top, w, h };
        }
        // Fallback to model values if DOM element isn't mounted yet
        return {
          x: n.x,
          y: n.y,
          w: n.w || 200,
          h: n.h || 80,
        };
      }

      function centerOf(n) {
        const b = nodeBounds(n);
        return { cx: b.x + b.w / 2, cy: b.y + b.h / 2 };
      }

      function renderNode(n) {
        let el = document.getElementById(n.id);
        if (!el) {
          el = document.createElement("div");
          el.className = "node node--" + n.type;
          el.id = n.id;
          el.innerHTML = `
            <div class="node__title editable-hint" contenteditable="false" data-placeholder="Untitled"></div>
            <div class="node__content"></div>
            <div class="node__ports"><div class="node__port"></div></div>
          `;
          boardEl.appendChild(el);

          // add resize handle
          const resizer = document.createElement("div");
          resizer.className = "node__resizer";
          el.appendChild(resizer);

          let resizing = false;
          let startW = 0,
            startH = 0,
            startX = 0,
            startY = 0;
          resizer.addEventListener("mousedown", (ev) => {
            ev.stopPropagation();
            resizing = true;
            startX = ev.clientX;
            startY = ev.clientY;
            startW = el.offsetWidth;
            startH = el.offsetHeight;
            document.body.style.userSelect = "none";
          });
          window.addEventListener("mousemove", (ev) => {
            if (!resizing) return;
            const dx = ev.clientX - startX;
            const dy = ev.clientY - startY;

            const maxW = 640,
              maxH = 600;
            const baseMinW = 160,
              baseMinH = 80;

            // Desired width from drag, clamped to base min/max
            let nextW = Math.max(
              baseMinW,
              Math.min(maxW, Math.round(startW + dx)),
            );
            // Apply width first to let text wrap and images scale, then measure content height
            el.style.width = nextW + "px";
            el.style.height = "auto";

            // Content-required height (includes title, content, tags, ports, etc.)
            const contentMinH = Math.ceil(el.scrollHeight);

            // Desired height from drag, but never below content-required height
            let nextH = Math.max(
              baseMinH,
              Math.min(maxH, Math.round(startH + dy)),
            );
            nextH = Math.max(nextH, contentMinH);

            // Commit
            n.w = nextW;
            n.h = nextH;
            el.style.height = nextH + "px";

            updateBoardExtent();
            renderEdges();
          });
          window.addEventListener("mouseup", () => {
            if (!resizing) return;
            resizing = false;
            document.body.style.userSelect = "";
            markDirty();
            updateSaveButton();
          });

          // select on click
          el.addEventListener("mousedown", (ev) => {
            if (ev.target && ev.target.closest(".node__resizer")) return;
            // if connect mode, handle port click like connection
            if (connectMode) {
              if (!connectFromId) {
                connectFromId = n.id;
                showStatus("Source selected. Pick a target.", { ttl: 2200 });
                renderGhostEdge();
              } else {
                addEdge(connectFromId, n.id);
                connectFromId = null;
                hideGhost();
                showStatus("Connected.", { ttl: 1800 });
              }
              ev.stopPropagation();
              return;
            }
            selectedEdgeId = null;
            selectedNodeId = n.id;
            updateSelections();
          });
          // right-click to open context menu for this node
          el.addEventListener("contextmenu", (ev) => {
            // If right-click occurs inside an editable rich text area, allow native menu for copy/paste
            const richTarget = ev.target && ev.target.closest(".rich");
            if (
              richTarget &&
              richTarget.getAttribute("contenteditable") === "true"
            ) {
              return; // let the browser show its native menu
            }
            ev.preventDefault();
            selectedEdgeId = null;
            selectedNodeId = n.id;
            updateSelections();
            // show menu at mouse position
            showContextMenu(ev.clientX, ev.clientY, { type: "node", id: n.id });
          });
          // drag
          let dragging = false,
            offX = 0,
            offY = 0;
          el.addEventListener("mousedown", (ev) => {
            if (ev.target && ev.target.closest(".node__resizer")) return;
            dragging = true;
            offX = ev.clientX - n.x;
            offY = ev.clientY - n.y;
          });
          window.addEventListener("mousemove", (ev) => {
            if (!dragging) return;
            n.x = ev.clientX - offX;
            n.y = ev.clientY - offY;
            el.style.left = n.x + "px";
            el.style.top = n.y + "px";
            updateBoardExtent();
            renderEdges(); // update edge positions live
          });
          window.addEventListener("mouseup", () => {
            if (dragging) {
              dragging = false;
              markDirty();
              updateSaveButton();
            }
          });

          // inline edits
          const titleEl = el.querySelector(".node__title");
          titleEl.addEventListener("input", () => {
            n.data.title = titleEl.textContent || "";
            markDirty();
            updateBoardExtent();
            renderEdges(); // keep connections glued to borders as size changes
          });
          // Make title editable only after a double-click
          let _preEditTitle = null;
          function placeCaretAtEnd(node) {
            const r = document.createRange();
            r.selectNodeContents(node);
            r.collapse(false);
            const sel = window.getSelection();
            sel.removeAllRanges();
            sel.addRange(r);
          }
          titleEl.addEventListener("dblclick", (ev) => {
            ev.stopPropagation();
            _preEditTitle = titleEl.textContent;
            titleEl.setAttribute("contenteditable", "true");
            // focus at end
            setTimeout(() => {
              titleEl.focus();
              placeCaretAtEnd(titleEl);
            }, 0);
          });
          // Press Enter to commit, Esc to cancel
          titleEl.addEventListener("keydown", (ev) => {
            if (ev.key === "Enter") {
              ev.preventDefault();
              titleEl.blur();
            } else if (ev.key === "Escape") {
              ev.preventDefault();
              if (_preEditTitle != null) titleEl.textContent = _preEditTitle;
              titleEl.blur();
            }
          });
          titleEl.addEventListener("blur", () => {
            // When leaving edit mode, lock it back
            titleEl.setAttribute("contenteditable", "false");
            _preEditTitle = null;
          });
          el.addEventListener("dblclick", (ev) => {
            if (n.type === "text") {
              const rich = el.querySelector(".rich");
              const rtb = el.querySelector(".rtb");
              if (rich) {
                rich.setAttribute("contenteditable", "true");
                el.classList.add("node--editing");
                setTimeout(() => {
                  try {
                    placeCaretAtEnd(rich);
                  } catch (_) {}
                  rich.focus();
                }, 0);
                if (rtb) rtb.style.display = "";
              }
              return; // no prompt
            }

            if (n.type === "image") {
              // Only trigger URL edit when the actual image is double-clicked
              const imgEl = ev.target && ev.target.closest("img");
              if (!imgEl || !el.contains(imgEl)) return; // ignore dblclicks elsewhere in the node
              const url = prompt("Edit image URL:", n.data.imageUrl ?? "");
              if (url !== null) n.data.imageUrl = url;
              renderNode(n);
              renderEdges();
              markDirty();
              return;
            }
          });
        }

        el.style.left = n.x + "px";
        el.style.top = n.y + "px";
        if (n.w) el.style.width = n.w + "px";
        else el.style.removeProperty("width");
        if (n.h) el.style.height = n.h + "px";
        else el.style.removeProperty("height");
        el.classList.toggle("selected", selectedNodeId === n.id);
        // Ensure node type modifier class follows BEM: node--{type}
        el.classList.forEach((c) => {
          if (
            (c.startsWith("node-") || c.startsWith("node--")) &&
            c !== "node"
          ) {
            el.classList.remove(c);
          }
        });
        el.classList.add("node--" + n.type);

        const titleEl = el.querySelector(".node__title");
        titleEl.setAttribute(
          "data-placeholder",
          n.type === "text"
            ? "Text title"
            : n.type === "image"
              ? "Image title"
              : "Link title",
        );
        // Preserve existing title; allow empty to show placeholder
        titleEl.textContent =
          typeof n.data.title === "string"
            ? n.data.title
            : n.type === "text"
              ? "Text"
              : n.type === "image"
                ? "Image"
                : "Link";

        const contentEl = el.querySelector(".node__content");
        if (n.type === "text") {
          const html =
            n.data.html ?? (n.data.text ? escapeHtml(n.data.text) : "");
          contentEl.innerHTML = `
            <div class="rtb" role="toolbar" aria-label="Text formatting">
              <button data-cmd="bold" title="Bold">B</button>
              <button data-cmd="italic" title="Italic"><i>I</i></button>
              <button data-cmd="underline" title="Underline"><u>U</u></button>
              <button data-cmd="insertUnorderedList" title="Bullet list">••</button>
              <button data-cmd="insertOrderedList" title="Numbered list">1.</button>
              <button data-action="link" title="Insert link">🔗</button>
              <button data-action="clear" title="Clear formatting">⨯</button>
            </div>
            <div class="rich" contenteditable="false" data-placeholder="Type text…">${html}</div>`;
        } else if (n.type === "image") {
          const desc = n.data.descHtml ?? "";
          contentEl.innerHTML = n.data.imageUrl
            ? `<img src="${escapeAttr(n.data.imageUrl)}" alt="">` +
              (() => {
                const hasDesc = !!(n.data.descHtml && n.data.descHtml.trim());
                const wrapDisplay = hasDesc ? "" : 'style="display:none"';
                const addBtn = hasDesc
                  ? ""
                  : `<button class="add-desc" type="button">+ Add description</button>`;
                return `
                  ${addBtn}
                  <div class="rtb" role="toolbar" aria-label="Text formatting" ${wrapDisplay}>
                    <button data-cmd="bold" title="Bold">B</button>
                    <button data-cmd="italic" title="Italic"><i>I</i></button>
                    <button data-cmd="underline" title="Underline"><u>U</u></button>
                    <button data-cmd="insertUnorderedList" title="Bullet list">••</button>
                    <button data-cmd="insertOrderedList" title="Numbered list">1.</button>
                    <button data-action="link" title="Insert link">🔗</button>
                    <button data-action="clear" title="Clear formatting">⨯</button>
                  </div>
                  <div class="rich" contenteditable="false" data-field="descHtml" data-placeholder="Add a description…" ${wrapDisplay}>${
                    n.data.descHtml ?? ""
                  }</div>
                `;
              })()
            : `<em>No image</em>`;
          // Wire up Add description toggler
          const addDescBtn = el.querySelector(".add-desc");
          if (addDescBtn) {
            addDescBtn.addEventListener("click", (ev) => {
              ev.stopPropagation();
              const rtb = el.querySelector(".rtb");
              const rich = el.querySelector('.rich[data-field="descHtml"]');
              if (rtb) rtb.style.display = "";
              if (rich) {
                rich.style.display = "";
                rich.setAttribute("contenteditable", "true");
                el.classList.add("node--editing");
                setTimeout(() => {
                  try {
                    placeCaretAtEnd(rich);
                  } catch (_) {}
                  rich.focus();
                }, 0);
              }
              addDescBtn.remove();
            });
          }
        } else if (n.type === "link") {
          const u = n.data.linkUrl ?? "";
          const desc = n.data.descHtml ?? "";
          if (!u) {
            contentEl.innerHTML = `<em>No link</em>`;
          } else if (n.data.preview) {
            const hasDesc = !!(n.data.descHtml && n.data.descHtml.trim());
            const wrapDisplay = hasDesc ? "" : 'style="display:none"';
            const addBtn = hasDesc
              ? ""
              : `<button class="add-desc" type="button">+ Add description</button>`;
            contentEl.innerHTML =
              renderLinkCard(n.data.preview, u) +
              `${addBtn}
               <div class="rtb" role="toolbar" aria-label="Text formatting" ${wrapDisplay}>
                 <button data-cmd="bold" title="Bold">B</button>
                 <button data-cmd="italic" title="Italic"><i>I</i></button>
                 <button data-cmd="underline" title="Underline"><u>U</u></button>
                 <button data-cmd="insertUnorderedList" title="Bullet list">••</button>
                 <button data-cmd="insertOrderedList" title="Numbered list">1.</button>
                 <button data-action="link" title="Insert link">🔗</button>
                 <button data-action="clear" title="Clear formatting">⨯</button>
               </div>
               <div class="rich" contenteditable="false" data-field="descHtml" data-placeholder="Add a description…" ${wrapDisplay}>${desc}</div>`;
          } else {
            // initial minimal view while loading
            const hasDesc = !!(n.data.descHtml && n.data.descHtml.trim());
            const wrapDisplay = hasDesc ? "" : 'style="display:none"';
            const addBtn = hasDesc
              ? ""
              : `<button class="add-desc" type="button">+ Add description</button>`;
            contentEl.innerHTML =
              `<a href="${escapeAttr(u)}" target="_blank" rel="noopener">${escapeHtml(u)}</a>` +
              `<div style="margin-top:6px;color:#9ca3af;font-size:12px;">Loading preview…</div>` +
              `${addBtn}
               <div class="rtb" role="toolbar" aria-label="Text formatting" ${wrapDisplay}>
                 <button data-cmd="bold" title="Bold">B</button>
                 <button data-cmd="italic" title="Italic"><i>I</i></button>
                 <button data-cmd="underline" title="Underline"><u>U</u></button>
                 <button data-cmd="insertUnorderedList" title="Bullet list">••</button>
                 <button data-cmd="insertOrderedList" title="Numbered list">1.</button>
                 <button data-action="link" title="Insert link">🔗</button>
                 <button data-action="clear" title="Clear formatting">⨯</button>
               </div>
               <div class="rich" contenteditable="false" data-field="descHtml" data-placeholder="Add a description…" ${wrapDisplay}>${desc}</div>`;
            // kick off preview fetch (once)
            (async () => {
              const p = await fetchLinkPreview(u);
              if (p) {
                n.data.preview = p;
                markDirty();
                renderNode(n);
                renderEdges();
              }
            })();
          }
          // Wire up Add description toggler for Link
          const addDescBtnL = el.querySelector(".add-desc");
          if (addDescBtnL) {
            addDescBtnL.addEventListener("click", (ev) => {
              ev.stopPropagation();
              const rtb = el.querySelector(".rtb");
              const rich = el.querySelector('.rich[data-field="descHtml"]');
              if (rtb) rtb.style.display = "";
              if (rich) {
                rich.style.display = "";
                rich.setAttribute("contenteditable", "true");
                el.classList.add("node--editing");
                setTimeout(() => {
                  try {
                    placeCaretAtEnd(rich);
                  } catch (_) {}
                  rich.focus();
                }, 0);
              }
              addDescBtnL.remove();
            });
          }
        }

        // Tags UI (common to all types)
        let tagsWrap = el.querySelector(".tags");
        if (!tagsWrap) {
          tagsWrap = document.createElement("div");
          tagsWrap.className = "tags";
          el.querySelector(".node__content").appendChild(tagsWrap);
        }
        renderTagChips(n, tagsWrap);

        let addTagBtn = el.querySelector(".add-tag");
        if (!addTagBtn) {
          addTagBtn = document.createElement("button");
          addTagBtn.className = "add-tag";
          addTagBtn.textContent = "+ tag";
          el.querySelector(".node__content").appendChild(addTagBtn);
          addTagBtn.addEventListener("click", (ev) => {
            ev.stopPropagation();
            const input = prompt("Add tags (comma separated or single #tag):");
            if (!input) return;
            const parts = input
              .split(",")
              .map((s) => normalizeTag(s))
              .filter(Boolean);
            const tags = ensureTags(n);
            for (const t of parts) {
              if (!tags.includes(t)) tags.push(t);
            }
            renderTagChips(n, tagsWrap);
            markDirty();
          });
        }
        // Attach rich text toolbar listeners (Text uses data.html; Image/Link use data.descHtml)
        {
          const rtb = el.querySelector(".rtb");
          const rich = el.querySelector(".rich");
          if (rtb && rich) {
            const field = n.type === "text" ? "html" : "descHtml";
            const isOptionalDesc =
              field === "descHtml" && (n.type === "image" || n.type === "link");

            function startEditing() {
              if (rich.getAttribute("contenteditable") === "true") return;
              rich.setAttribute("contenteditable", "true");
              el.classList.add("node--editing");
              setTimeout(() => {
                try {
                  placeCaretAtEnd(rich);
                } catch (_) {}
                rich.focus();
              }, 0);
            }
            function stopEditing() {
              if (rich.getAttribute("contenteditable") !== "true") return;
              rich.setAttribute("contenteditable", "false");
              el.classList.remove("node--editing");
            }

            function ensureAddDescButton() {
              if (!isOptionalDesc) return;
              let addBtn = el.querySelector(".add-desc");
              if (!addBtn) {
                addBtn = document.createElement("button");
                addBtn.className = "add-desc";
                addBtn.type = "button";
                addBtn.textContent = "+ Add description";
                addBtn.addEventListener("click", (ev) => {
                  ev.stopPropagation();
                  if (rtb) rtb.style.display = "";
                  if (rich) {
                    rich.style.display = "";
                    startEditing();
                  }
                  addBtn.remove();
                });
                el.querySelector(".node__content").insertBefore(addBtn, rtb);
              }
            }

            function maybeCollapseIfEmpty() {
              if (!isOptionalDesc) return;
              const plain = (rich.textContent || "").trim();
              if (!plain.length) {
                n.data.descHtml = "";
                if (rtb) rtb.style.display = "none";
                if (rich) {
                  rich.style.display = "none";
                  rich.innerHTML = "";
                }
                ensureAddDescButton();
              }
            }

            // Enter editing on double click inside the rich area
            rich.addEventListener("dblclick", (ev) => {
              ev.stopPropagation();
              startEditing();
            });

            // Keep focus and ensure editing when interacting with the toolbar
            rtb.addEventListener("mousedown", (ev) => {
              ev.preventDefault();
              startEditing();
            });
            rtb.addEventListener("click", (ev) => {
              const btn = ev.target.closest("button");
              if (!btn) return;
              const cmd = btn.getAttribute("data-cmd");
              const act = btn.getAttribute("data-action");
              startEditing();
              if (cmd) {
                document.execCommand(cmd, false, null);
                n.data[field] = rich.innerHTML;
                markDirty();
                renderEdges();
                maybeCollapseIfEmpty();
              } else if (act === "link") {
                const url = prompt("Link URL", "https://");
                if (url) document.execCommand("createLink", false, url);
                n.data[field] = rich.innerHTML;
                markDirty();
                maybeCollapseIfEmpty();
              } else if (act === "clear") {
                document.execCommand("removeFormat");
                const a = rich.querySelector("a");
                if (a) {
                  const t = document.createTextNode(a.textContent || "");
                  a.replaceWith(t);
                }
                rich.innerHTML = "";
                n.data[field] = "";
                markDirty();
                maybeCollapseIfEmpty();
              }
            });

            const syncHtml = () => {
              n.data[field] = rich.innerHTML;
              markDirty();
              maybeCollapseIfEmpty();
            };
            rich.addEventListener("input", syncHtml);
            rich.addEventListener("blur", () => {
              syncHtml();
              stopEditing();
            });
            rich.addEventListener("keydown", (ev) => {
              if (ev.key === "Escape") {
                ev.preventDefault();
                stopEditing();
                rich.blur();
              } else if (ev.key === "Enter" && !ev.shiftKey) {
                ev.preventDefault();
                syncHtml();
                stopEditing();
                rich.blur();
              }
            });
          }
        }
        // Toggle resizer visibility based on node type (text, image, link are resizable)
        const resizerEl = el.querySelector(".node__resizer");
        if (resizerEl) {
          resizerEl.style.display =
            n.type === "text" || n.type === "image" || n.type === "link"
              ? ""
              : "none";
        }
      }

      function renderNodes() {
        // Remove DOM nodes that no longer exist in data
        const ids = new Set(board.nodes.map((n) => n.id));
        document.querySelectorAll(".node").forEach((el) => {
          if (!ids.has(el.id)) el.remove();
        });
        board.nodes.forEach(renderNode);
      }

      // Compute an anchor point on the boundary of node n that faces (ox, oy)
      function anchorPoint(n, ox, oy) {
        const b = nodeBounds(n);
        const cx = b.x + b.w / 2;
        const cy = b.y + b.h / 2;
        const dx = ox - cx;
        const dy = oy - cy;

        // Choose side by dominant axis
        if (Math.abs(dx) > Math.abs(dy)) {
          // left/right
          if (dx >= 0) {
            return { x: b.x + b.w, y: cy, side: "right" };
          } else {
            return { x: b.x, y: cy, side: "left" };
          }
        } else {
          // top/bottom
          if (dy >= 0) {
            return { x: cx, y: b.y + b.h, side: "bottom" };
          } else {
            return { x: cx, y: b.y, side: "top" };
          }
        }
      }

      // Build a synthetic “target” anchor at the mouse so the curve bends nicely.
      // We pick the side opposite to where the mouse is relative to the source node,
      // so control points push outward (pleasant S-curve).
      function mouseAnchor(fromNode, mx, my) {
        const b = nodeBounds(fromNode);
        const cx = b.x + (b.w || 0) / 2;
        const cy = b.y + (b.h || 0) / 2;
        const dx = mx - cx;
        const dy = my - cy;
        let side;
        if (Math.abs(dx) > Math.abs(dy)) {
          side = dx >= 0 ? "left" : "right"; // opposite of mouse horizontal side
        } else {
          side = dy >= 0 ? "top" : "bottom"; // opposite of mouse vertical side
        }
        return { x: mx, y: my, side };
      }

      // Smooth cubic path between two anchors, with curvature adaptive to distance
      function smoothCubic(a, b) {
        const x1 = a.x,
          y1 = a.y,
          x2 = b.x,
          y2 = b.y;
        const dx = Math.abs(x2 - x1);
        const dy = Math.abs(y2 - y1);
        const d = Math.max(dx, dy);
        const c = Math.min(160, Math.max(40, d * 0.6)); // curvature

        let c1x = x1,
          c1y = y1,
          c2x = x2,
          c2y = y2;

        // Push control points outward from each side
        switch (a.side) {
          case "right":
            c1x += c;
            break;
          case "left":
            c1x -= c;
            break;
          case "top":
            c1y -= c;
            break;
          case "bottom":
            c1y += c;
            break;
        }
        switch (b.side) {
          case "right":
            c2x -= c;
            break;
          case "left":
            c2x += c;
            break;
          case "top":
            c2y += c;
            break;
          case "bottom":
            c2y -= c;
            break;
        }

        return `M ${x1} ${y1} C ${c1x} ${c1y}, ${c2x} ${c2y}, ${x2} ${y2}`;
      }

      function computeContentExtent(pad = 160) {
        let maxX = 0,
          maxY = 0;
        for (const n of board.nodes) {
          const b = nodeBounds(n);
          const w = b.w || 240;
          const h = b.h || 100;
          maxX = Math.max(maxX, b.x + w);
          maxY = Math.max(maxY, b.y + h);
        }
        const rect = boardEl.getBoundingClientRect();
        const w = Math.max(maxX + pad, rect.width);
        const h = Math.max(maxY + pad, rect.height);
        return { w, h };
      }

      function updateBoardExtent() {
        const { w, h } = computeContentExtent(160);
        const sizer = document.getElementById("boardSizer");
        if (sizer) {
          sizer.style.width = w + "px";
          sizer.style.height = h + "px";
        }
        edgesSvg.setAttribute("width", w);
        edgesSvg.setAttribute("height", h);
        edgesSvg.style.width = w + "px";
        edgesSvg.style.height = h + "px";
      }

      function renderEdges() {
        edgesSvg.innerHTML = "";
        updateBoardExtent();
        if (!visibleNodeIds) {
          visibleNodeIds = new Set(board.nodes.map((n) => n.id));
        }

        for (const e of board.edges) {
          const s = board.nodes.find((n) => n.id === e.sourceId);
          const t = board.nodes.find((n) => n.id === e.targetId);
          if (!s || !t) continue;
          if (!visibleNodeIds.has(s.id) || !visibleNodeIds.has(t.id)) continue;
          const sc = centerOf(s);
          const tc = centerOf(t);
          const a1 = anchorPoint(s, tc.cx, tc.cy);
          const a2 = anchorPoint(t, sc.cx, sc.cy);
          const g = document.createElementNS("http://www.w3.org/2000/svg", "g");
          g.setAttribute("data-id", e.id);

          // Path
          const path = document.createElementNS(
            "http://www.w3.org/2000/svg",
            "path",
          );
          path.setAttribute("d", smoothCubic(a1, a2));
          let cls = "edge" + (selectedEdgeId === e.id ? " edge--selected" : "");
          if (e.dashed) cls += " edge--dashed";
          path.setAttribute("class", cls);
          if (e.color) {
            // Use inline style so it overrides the .edge CSS rule
            path.style.stroke = e.color;
          } else {
            path.style.stroke = null; // fall back to CSS (.edge { stroke: red; })
          }
          path.dataset.id = e.id;

          // Label (optional)
          if (e.label) {
            const tx = (a1.x + a2.x) / 2;
            const ty = (a1.y + a2.y) / 2 - 2; // closer to the curve
            const text = document.createElementNS(
              "http://www.w3.org/2000/svg",
              "text",
            );
            text.setAttribute("x", tx);
            text.setAttribute("y", ty);
            text.setAttribute("class", "edge__label");
            text.textContent = e.label;

            // Click/ctx on label behave like the edge
            text.addEventListener("click", (ev) => {
              selectedNodeId = null;
              selectedEdgeId = e.id;
              updateSelections();
              ev.stopPropagation();
              return false;
            });
            text.addEventListener("contextmenu", (ev) => {
              ev.preventDefault();
              ev.stopPropagation();
              selectedNodeId = null;
              selectedEdgeId = e.id;
              updateSelections();
              showContextMenu(ev.clientX, ev.clientY, {
                type: "edge",
                id: e.id,
              });
              return false;
            });
            g.appendChild(text);
          }

          // Events on path
          path.addEventListener("click", (ev) => {
            selectedNodeId = null;
            selectedEdgeId = e.id;
            updateSelections();
            ev.stopPropagation();
            return false;
          });
          path.addEventListener("contextmenu", (ev) => {
            ev.preventDefault();
            ev.stopPropagation();
            selectedNodeId = null;
            selectedEdgeId = e.id;
            updateSelections();
            showContextMenu(ev.clientX, ev.clientY, { type: "edge", id: e.id });
            return false;
          });

          g.appendChild(path);

          // Add endpoint circles
          const startCircle = document.createElementNS(
            "http://www.w3.org/2000/svg",
            "circle",
          );
          startCircle.setAttribute("cx", a1.x);
          startCircle.setAttribute("cy", a1.y);
          startCircle.setAttribute("r", "4");
          startCircle.setAttribute("class", "edge__endpoint");

          const endCircle = document.createElementNS(
            "http://www.w3.org/2000/svg",
            "circle",
          );
          endCircle.setAttribute("cx", a2.x);
          endCircle.setAttribute("cy", a2.y);
          endCircle.setAttribute("r", "4");
          endCircle.setAttribute("class", "edge__endpoint");

          g.appendChild(startCircle);
          g.appendChild(endCircle);

          edgesSvg.appendChild(g);
        }
        // Re-draw ghost on top if we're mid-connection
        if (connectMode && connectFromId) {
          renderGhostEdge();
        } else {
          hideGhost();
        }
      }

      function updateSelections() {
        // nodes
        document.querySelectorAll(".node").forEach((el) => {
          el.classList.toggle("selected", el.id === selectedNodeId);
        });
        // edges
        document.querySelectorAll("path.edge").forEach((p) => {
          p.classList.toggle("edge--selected", p.dataset.id === selectedEdgeId);
        });
      }

      function render() {
        renderNodes();
        renderEdges();
        applySearchFilter();
        adjustBoardHeight();
      }

      function escapeHtml(s) {
        return (s ?? "").toString().replace(
          /[&<>"']/g,
          (c) =>
            ({
              "&": "&amp;",
              "<": "&lt;",
              ">": "&gt;",
              '"': "&quot;",
              "'": "&#39;",
            })[c],
        );
      }
      function escapeAttr(s) {
        return escapeHtml(s);
      }

      function ensureTags(n) {
        if (!n.data) n.data = {};
        if (!Array.isArray(n.data.tags)) n.data.tags = [];
        return n.data.tags;
      }
      function normalizeTag(t) {
        return (t || "").toString().trim().replace(/^#+/, "").toLowerCase();
      }
      function renderTagChips(n, hostEl) {
        const tags = ensureTags(n);
        hostEl.innerHTML = "";
        for (let i = 0; i < tags.length; i++) {
          const tag = tags[i];
          const chip = document.createElement("span");
          chip.className = "chip";
          chip.innerHTML = `<span>#${escapeHtml(
            tag,
          )}</span> <button title="Remove tag" data-i="${i}">✕</button>`;
          chip.querySelector("button").addEventListener("click", (ev) => {
            ev.stopPropagation();
            tags.splice(i, 1);
            renderTagChips(n, hostEl);
            markDirty();
          });
          hostEl.appendChild(chip);
        }
      }

      function plainTextFromHtml(html) {
        const tmp = document.createElement("div");
        tmp.innerHTML = html || "";
        return (tmp.textContent || tmp.innerText || "").trim();
      }

      let currentQuery = "";
      let visibleNodeIds = null; // Set<string>

      function parseQuery(q) {
        const parts = (q || "").trim().split(/\\s+/).filter(Boolean);
        const tags = [];
        const terms = [];
        for (const p of parts) {
          if (p.startsWith("#")) tags.push(normalizeTag(p));
          else terms.push(p.toLowerCase());
        }
        return { tags, terms };
      }

      function nodeMatches(n, q) {
        if (!q || (!q.tags.length && !q.terms.length)) return true;
        const tags = ensureTags(n);
        // tag logic: all query tags must be present
        for (const t of q.tags) {
          if (!tags.map(normalizeTag).includes(t)) return false;
        }
        if (!q.terms.length) return true;
        const hay = [
          n.data?.title || "",
          n.data?.text || "",
          plainTextFromHtml(n.data?.html || ""),
          n.data?.linkUrl || "",
          tags.join(" "),
        ]
          .join(" ")
          .toLowerCase();
        return q.terms.every((term) => hay.includes(term));
      }

      function applySearchFilter() {
        const q = parseQuery(currentQuery);
        visibleNodeIds = new Set();
        for (const n of board.nodes) {
          const el = document.getElementById(n.id);
          const match = nodeMatches(n, q);
          if (el) {
            el.style.display = match ? "" : "none";
            el.classList.toggle("dim", !match && currentQuery.length > 0);
          }
          if (match) visibleNodeIds.add(n.id);
        }
        renderEdges();
      }

      function exportBoard() {
        // Let the server stream a ZIP (includes board.json and uploads/)
        showStatus("Export in progress…", { sticky: true });
        // Trigger the download
        window.location.href = `/api/board/${encodeURIComponent(window.__globals.boardId)}/export`;
        // After a short delay, update the message to guide user
        setTimeout(() => {
          showStatus(
            "Export initiated. Please check your downloads folder once it completes.",
            {
              sticky: true,
            },
          );
        }, 500);
      }

      async function fetchLinkPreview(url) {
        try {
          const resp = await fetch("/api/link-preview", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ url }),
          });
          if (!resp.ok) throw new Error("Failed");
          return await resp.json();
        } catch (e) {
          return null;
        }
      }

      function renderLinkCard(preview, href) {
        const title = escapeHtml(preview?.title || href || "Link");
        const desc = escapeHtml(preview?.description || "");
        const site = escapeHtml(
          preview?.siteName || (href ? new URL(href).hostname : ""),
        );
        const icon = preview?.icon
          ? `<img class="icon" src="${escapeAttr(preview.icon)}" alt="">`
          : "";
        const img = preview?.image
          ? `<img class="thumb" src="${escapeAttr(preview.image)}" alt="">`
          : `<div class="thumb"></div>`;
        const safeHref = escapeAttr(href || preview?.url || "#");
        return `
          <a href="${safeHref}" target="_blank" rel="noopener" class="link-card">
            ${img}
            <div class="meta">
              <div class="title">${title}</div>
              ${desc ? `<div class="desc">${desc}</div>` : ""}
              <div class="site">${icon}${site}</div>
            </div>
          </a>
        `;
      }

      function validateImported(json) {
        if (!json || typeof json !== "object")
          throw new Error("File is not a JSON object");
        if (!Array.isArray(json.nodes) || !Array.isArray(json.edges))
          throw new Error("Missing nodes/edges arrays");
        // Minimal normalization: ensure required fields exist
        json.id = json.id || "board-1";
        json.title = json.title || "Imported Board";
        json.createdAt = json.createdAt || new Date().toISOString();
        json.updatedAt = new Date().toISOString();
        json.nodes = json.nodes.map((n, i) => ({
          id: n.id || `n_imp_${i}`,
          type: n.type || "text",
          x: Number.isFinite(n.x) ? n.x : 100 + i * 20,
          y: Number.isFinite(n.y) ? n.y : 100 + i * 20,
          w: n.w,
          h: n.h,
          data: n.data || {},
        }));
        json.edges = json.edges
          .filter((e) => e && e.sourceId && e.targetId)
          .map((e, i) => ({
            id: e.id || `e_imp_${i}`,
            sourceId: e.sourceId,
            targetId: e.targetId,
          }));
        return json;
      }

      // --- Auto-layout (simple layered layout, dagre-like) ---
      function buildGraph() {
        const nodes = board.nodes.map((n) => ({ id: n.id }));
        const edges = board.edges.map((e) => ({
          from: e.sourceId,
          to: e.targetId,
        }));
        const adj = new Map();
        const indeg = new Map();
        for (const n of nodes) {
          adj.set(n.id, []);
          indeg.set(n.id, 0);
        }
        for (const e of edges) {
          if (!adj.has(e.from)) adj.set(e.from, []);
          adj.get(e.from).push(e.to);
          if (indeg.has(e.to)) indeg.set(e.to, indeg.get(e.to) + 1);
          else indeg.set(e.to, 1);
        }
        return { nodes, edges, adj, indeg };
      }

      function topoLayers() {
        const { nodes, adj, indeg } = buildGraph();
        const q = [];
        const indegCopy = new Map(indeg);
        for (const n of nodes)
          if ((indegCopy.get(n.id) || 0) === 0) q.push(n.id);
        const layers = [];
        const placed = new Set();
        // Kahn-like layering: nodes with indegree==0 form layer 0, then peel
        let current = q.slice();
        let visitedCount = 0;
        while (current.length) {
          layers.push(current);
          const next = [];
          for (const id of current) {
            placed.add(id);
            visitedCount++;
            const outs = adj.get(id) || [];
            for (const v of outs) {
              indegCopy.set(v, (indegCopy.get(v) || 0) - 1);
              if (indegCopy.get(v) === 0) next.push(v);
            }
          }
          current = next;
        }
        // Any remaining nodes are in cycles; place them in subsequent layers by a simple BFS from any unplaced
        if (visitedCount < nodes.length) {
          const rest = nodes.map((n) => n.id).filter((id) => !placed.has(id));
          // group into chunks of up to 5 per layer to avoid stacking all in one
          const chunk = 5;
          for (let i = 0; i < rest.length; i += chunk)
            layers.push(rest.slice(i, i + chunk));
        }
        return layers;
      }

      function autoLayout(direction = "LR") {
        if (!board.nodes.length) return;
        // Ensure DOM sizes are measured before layout
        renderNodes();
        // Build layered structure
        const layers = topoLayers();
        const layerGap = 180; // distance between layers
        const nodeGap = 80; // distance between nodes within a layer

        // Precompute sizes
        const size = new Map();
        for (const n of board.nodes) {
          const b = nodeBounds(n);
          size.set(n.id, { w: b.w || 240, h: b.h || 100 });
        }

        if (direction === "LR") {
          // Layers progress left-to-right; within each layer, nodes are stacked vertically
          let x = 80;
          for (const layer of layers) {
            // compute max width in this layer
            let maxW = 0;
            for (const id of layer) {
              maxW = Math.max(maxW, size.get(id)?.w || 240);
            }
            // vertical placement centered around the board's current view
            let y = 80;
            for (const id of layer) {
              const n = board.nodes.find((nn) => nn.id === id);
              if (!n) continue;
              const wh = size.get(id) || { w: 240, h: 100 };
              n.x = x;
              n.y = y;
              y += wh.h + nodeGap;
            }
            x += maxW + layerGap;
          }
        } else {
          // TB top-to-bottom
          let y = 80;
          for (const layer of layers) {
            let maxH = 0;
            for (const id of layer) {
              maxH = Math.max(maxH, size.get(id)?.h || 100);
            }
            let x = 80;
            for (const id of layer) {
              const n = board.nodes.find((nn) => nn.id === id);
              if (!n) continue;
              const wh = size.get(id) || { w: 240, h: 100 };
              n.x = x;
              n.y = y;
              x += wh.w + nodeGap;
            }
            y += maxH + layerGap;
          }
        }
        render();
        markDirty();
        setStatus("Auto-layout applied");
      }

      // Ensure status bar hint is rendered on first load
      renderStatusBar();
      adjustBoardHeight();

      function openAbout() {
        document.getElementById("aboutAppVersion").textContent =
          window.__globals.appVersion;
        document.getElementById("aboutSchemaVersion").textContent = String(
          board.schemaVersion || 1,
        );
        document.getElementById("aboutBoardName").textContent =
          board.title || "Untitled Board";
        aboutModal.classList.add("show");
      }
      function closeAbout() {
        aboutModal.classList.remove("show");
      }

      // Toolbar wiring
      $("#addText").onclick = () =>
        addNode("text", viewCenter(), { text: "New note..." });
      $("#addImage").onclick = () => addNode("image", viewCenter());
      $("#addLink").onclick = () => addNode("link", viewCenter());
      $("#connect").onclick = toggleConnectMode;
      document.getElementById("autoLayout").onclick = () => autoLayout("LR");
      exportBtn.onclick = exportBoard;
      importBtn.onclick = () => importFile.click();
      infoBtn.addEventListener("click", openAbout);
      aboutClose.addEventListener("click", closeAbout);
      aboutModal.addEventListener("click", (e) => {
        if (e.target === aboutModal) closeAbout();
      });
      document.addEventListener("keydown", (e) => {
        if (e.key === "Escape") {
          if (aboutModal.classList.contains("show")) closeAbout();
          if (connectMode && connectFromId) {
            connectFromId = null;
            hideGhost();
            showStatus("Connect cancelled");
          }
        }
      });

      boardEl.addEventListener("mousedown", (ev) => {
        if (!ev.target || ev.target === boardEl) {
          if (connectMode && connectFromId) {
            connectFromId = null;
            hideGhost();
            showStatus("Connect cancelled");
          }
        }
      });
      importFile.addEventListener("change", async (e) => {
        const file = e.target.files?.[0];
        if (!file) return;
        try {
          if (/\.zip$/i.test(file.name)) {
            // Probe first
            const probeFd = new FormData();
            probeFd.append("bundle", file);
            const probeResp = await fetch(
              `/api/board/${encodeURIComponent(window.__globals.boardId)}/validate-import`,
              {
                method: "POST",
                body: probeFd,
              },
            );
            if (!probeResp.ok)
              throw new Error(`Probe failed (${probeResp.status})`);
            const meta = await probeResp.json();

            if (meta.boardId === board.id) {
              const ok = confirm(
                `You're importing the SAME board (ID: ${meta.boardId}).\nTitle: ${
                  meta.title || "(untitled)"
                }\nReplace the current board with the imported one?`,
              );
              if (!ok) {
                setStatus("Import cancelled.");
                importFile.value = "";
                return;
              }
            }

            setStatus("Importing zip…");
            const fd = new FormData();
            fd.append("bundle", file);
            const resp = await fetch(
              `/api/board/${encodeURIComponent(window.__globals.boardId)}/import`,
              {
                method: "POST",
                body: fd,
              },
            );
            if (!resp.ok) throw new Error(`Import failed (${resp.status})`);
            const json = await resp.json();
            board = json;
            render();
            markDirty();
            setStatus(`Imported ${file.name}`);
          } else {
            const text = await file.text();
            const json = JSON.parse(text);
            const validated = validateImported(json);
            if (validated.id === board.id) {
              const ok = confirm(
                `You're importing the SAME board (ID: ${validated.id}). Replace the current board with the imported one?`,
              );
              if (!ok) {
                setStatus("Import cancelled.");
                importFile.value = "";
                return;
              }
            }
            board = validated;
            render();
            markDirty();
            setStatus(`Imported ${file.name}`);
          }
        } catch (err) {
          console.error(err);
          alert(`Import failed: ${err.message || err}`);
          setStatus("Import failed.");
        } finally {
          importFile.value = "";
        }
      });
      // Search wiring (debounced + clear)
      let searchTimer = null;
      const clearSearchBtn = document.getElementById("clearSearch");
      const updateClearBtn = () => {
        clearSearchBtn.disabled = !searchInput.value;
      };
      updateClearBtn();

      searchInput.addEventListener("input", (e) => {
        currentQuery = e.target.value || "";
        if (searchTimer) clearTimeout(searchTimer);
        searchTimer = setTimeout(() => applySearchFilter(), 150);
        updateClearBtn();
      });

      // Allow Esc to clear search without triggering global handlers
      searchInput.addEventListener("keydown", (e) => {
        if (e.key === "Escape") {
          searchInput.value = "";
          currentQuery = "";
          applySearchFilter();
          updateClearBtn();
          e.stopPropagation();
        }
      });

      // Clear button
      clearSearchBtn.addEventListener("click", () => {
        searchInput.value = "";
        currentQuery = "";
        applySearchFilter();
        updateClearBtn();
        searchInput.focus();
      });
      if (isOwner) {
        $("#save").onclick = saveBoard;
        $("#reset").onclick = resetBoard;
      }

      function viewCenter() {
        const rect = boardEl.getBoundingClientRect();
        return {
          x: boardEl.scrollLeft + rect.width / 2 - 120,
          y: boardEl.scrollTop + rect.height / 2 - 60,
        };
      }

      /** Info Button */
      function openAbout() {
        document.getElementById("aboutAppVersion").textContent =
          window.__globals.appVersion;
        document.getElementById("aboutSchemaVersion").textContent = String(
          board.schemaVersion || 1,
        );
        document.getElementById("aboutBoardName").textContent =
          board.title || "Untitled Board";
        aboutModal.classList.add("show");
      }

      function closeAbout() {
        aboutModal.classList.remove("show");
      }

      infoBtn.addEventListener("click", openAbout);
      aboutClose.addEventListener("click", closeAbout);
      // Close when clicking the backdrop
      aboutModal.addEventListener("click", (e) => {
        if (e.target === aboutModal) closeAbout();
      });
      // Close on Esc
      document.addEventListener("keydown", (e) => {
        if (e.key === "Escape" && aboutModal.classList.contains("show"))
          closeAbout();
      });

      // Settings modal wiring (always visible; non-owners see read-only UI)
      {
        const settingsBtn = document.getElementById("settingsBtn");
        const settingsModal = document.getElementById("settingsModal");
        const settingsClose = document.getElementById("settingsClose");
        const visibilitySelect = document.getElementById("visibilitySelect");
        const statusSelect = document.getElementById("statusSelect");
        const titleInput = document.getElementById("titleInput");
        const saveMetaBtn = document.getElementById("saveMetaBtn");
        const deleteBoardBtn = document.getElementById("deleteBoardBtn");
        const confirmIdInput = document.getElementById("confirmIdInput");
        const settingsNotice = document.getElementById("settingsNotice");

        function openSettings() {
          // initialize values from server-globals and from current UI
          titleInput.value =
            window.__globals.boardTitle ||
            document.getElementById("boardName").textContent ||
            "";
          visibilitySelect.value = (
            window.__globals.boardVisibility || "public"
          ).toLowerCase();
          statusSelect.value = (
            window.__globals.boardStatus || "draft"
          ).toLowerCase();
          settingsModal.classList.add("show");
        }
        function closeSettings() {
          settingsModal.classList.remove("show");
        }
        // Disable controls for non-owners
        if (!isOwner) {
          settingsNotice.style.display = "block";
          titleInput.setAttribute("readonly", "true");
          titleInput.setAttribute("disabled", "true");
          visibilitySelect.setAttribute("disabled", "true");
          statusSelect.setAttribute("disabled", "true");
          saveMetaBtn.setAttribute("disabled", "true");
          if (deleteBoardBtn) {
            deleteBoardBtn.setAttribute("disabled", "true");
            deleteBoardBtn.style.opacity = "0.6";
            deleteBoardBtn.style.cursor = "not-allowed";
          }
        }

        settingsBtn?.addEventListener("click", openSettings);
        settingsClose?.addEventListener("click", closeSettings);
        settingsModal?.addEventListener("click", (e) => {
          if (e.target === settingsModal) closeSettings();
        });

        saveMetaBtn?.addEventListener("click", async () => {
          try {
            const payload = {
              visibility: visibilitySelect.value,
              status: statusSelect.value,
              title: titleInput.value,
            };
            const resp = await fetch(
              `/api/board/${encodeURIComponent(window.__globals.boardId)}/meta`,
              {
                method: "PATCH",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify(payload),
              },
            );
            const data = await resp.json().catch(() => ({}));
            if (!resp.ok) throw new Error(data?.error || "Update failed");
            // Reflect immediately in UI and local state
            const newTitle = data.title || titleInput.value;
            document.getElementById("boardName").textContent = newTitle;
            if (typeof board === "object") board.title = newTitle;
            window.__globals.boardTitle = newTitle;
            if (data.visibility)
              window.__globals.boardVisibility = data.visibility;
            if (data.status) window.__globals.boardStatus = data.status;
            // Keep settings button visible for owners regardless of visibility
            closeSettings();
            showStatus("Settings updated", { ttl: 1500 });
          } catch (e) {
            showStatus(e.message || "Update failed", { sticky: true });
          }
        });

        deleteBoardBtn?.addEventListener("click", async () => {
          if (!isOwner) {
            showStatus("Only the owner can delete this board.", {
              sticky: true,
            });
            return;
          }
          const confirmId = (confirmIdInput?.value || "").trim();
          if (confirmId !== window.__globals.boardId) {
            alert("Type the exact board id to confirm deletion.");
            return;
          }
          if (
            !confirm(
              "This will permanently delete the board and its data. Continue?",
            )
          )
            return;
          try {
            const resp = await fetch(
              `/api/board/${encodeURIComponent(window.__globals.boardId)}`,
              {
                method: "DELETE",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify({ confirm: true, confirmId }),
              },
            );
            const data = await resp.json().catch(() => ({}));
            if (!resp.ok) throw new Error(data?.error || "Delete failed");
            window.location.href = "/";
          } catch (e) {
            showStatus(e.message || "Delete failed", { sticky: true });
          }
        });
      }
      /** end of Info Button */

      function toggleConnectMode() {
        connectMode = !connectMode;
        connectFromId = null;
        setConnectMode(connectMode);
      }

      document.addEventListener("keydown", (e) => {
        const typing = isTypingTarget(e.target);

        if (!typing && (e.key === "Delete" || e.key === "Backspace")) {
          e.preventDefault(); // avoid browser back
          removeSelection();
          return;
        }
        if (!typing && e.key.toLowerCase() === "c") {
          toggleConnectMode();
          return;
        }
        if (e.key.toLowerCase() === "l" && (e.metaKey || e.ctrlKey)) {
          e.preventDefault();
          autoLayout("LR");
        }
      });

      // click blank space to clear selection
      boardEl.addEventListener("mousedown", (ev) => {
        if (ev.target === boardEl || ev.target === edgesSvg) {
          hideContextMenu();
          selectedNodeId = null;
          selectedEdgeId = null;
          updateSelections();
        }
      });
      // Allow dropping a .json file onto the board to import
      boardEl.addEventListener("dragover", (e) => {
        e.preventDefault();
      });
      boardEl.addEventListener("drop", async (e) => {
        e.preventDefault();
        const file = e.dataTransfer?.files?.[0];
        if (!file || !file.name.toLowerCase().endsWith(".json")) return;
        try {
          const text = await file.text();
          const json = JSON.parse(text);
          const validated = validateImported(json);
          board = validated;
          render();
          markDirty();
          setStatus(`Imported ${file.name}`);
        } catch (err) {
          console.error(err);
          alert(`Import failed: ${err.message || err}`);
          setStatus("Import failed.");
        }
      });

      // Load existing board
      async function loadBoard() {
        // try {
        //   const resp = await fetch(
        //     `/api/board/${encodeURIComponent(window.__globals.boardId)}`
        //   );
        //   const data = await resp.json();
        //   board = data;
        //   render();
        //   boardNameEl.textContent = board.title || "";
        //   lastSavedJSON = computeSnapshot();
        //   updateSaveButton();
        //   currentQuery = searchInput.value || "";
        //   applySearchFilter();
        //   setStatus("Loaded.");
        //   renderStatusBar();
        // } catch (e) {
        //   setStatus("No saved board yet. Start adding nodes.");
        //   renderStatusBar();
        // } finally {
        //   adjustBoardHeight();
        // }
      }

      async function saveBoard() {
        if (!saveBtn) return;

        saveBtn.disabled = true;
        setStatus("Saving…");
        try {
          const resp = await fetch(
            `/api/board/${encodeURIComponent(window.__globals.boardId)}`,
            {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify(board),
            },
          );
          const data = await resp.json();
          board = data;
          boardNameEl.textContent = board.title || "";
          lastSavedJSON = computeSnapshot();
          updateSaveButton();
          setStatus(
            "Saved at " + new Date(board.updatedAt).toLocaleTimeString(),
          );
        } catch (e) {
          saveBtn.disabled = false;
          setStatus("Save failed.");
          console.error(e);
        }
      }

      function resetBoard() {
        if (
          !confirm("Clear all nodes/edges? This will NOT save automatically.")
        )
          return;
        const now = new Date().toISOString();
        board = {
          id: board.id || "board-1",
          title: "My Evidence Board",
          nodes: [],
          edges: [],
          createdAt: board.createdAt || now,
          updatedAt: now,
        };
        boardNameEl.textContent = board.title || "";
        render();
        // Mark as dirty so user can decide to Save manually
        markDirty();
        setStatus("Board reset. Click Save to persist.");
      }

      // Image upload handling
      const fileInputEl = document.getElementById("fileInput");
      const uploadBtnEl = document.getElementById("uploadImage");

      uploadBtnEl.onclick = () => fileInputEl.click();

      fileInputEl.addEventListener("change", async (e) => {
        const file = e.target.files?.[0];
        if (!file) return;
        try {
          setStatus("Uploading…");
          const fd = new FormData();
          fd.append("image", file);
          const res = await fetch(
            `/api/board/${encodeURIComponent(window.__globals.boardId)}/upload-image`,
            {
              method: "POST",
              body: fd,
            },
          );
          if (!res.ok) throw new Error("Upload failed");
          const data = await res.json();
          addNode("image", viewCenter(), {
            imageUrl: data.url,
            title: file.name,
          });
          markDirty();
          setStatus("Uploaded.");
        } catch (err) {
          console.error(err);
          alert(err.message || "Upload failed");
          setStatus("Upload failed.");
        } finally {
          fileInputEl.value = "";
        }
      });
      // End of image upload handling

      loadBoard();
    </script>
  </body>
</html>
