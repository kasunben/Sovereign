<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>PaperTrail â€” map your evidence, follow the story.</title>
    <link rel="icon" type="image/svg+xml" href="/assets/favicon.svg" />

    <!-- Primary SEO -->
    <meta name="application-name" content="PaperTrail" />
    <meta
      name="description"
      content="PaperTrail is a lightweight evidence-mapping app. Create text, image, and link nodes, connect them, auto-layout, and import/export boards."
    />
    <meta
      name="keywords"
      content="evidence board, investigation, graph, nodes, links, mind map, research, PaperTrail"
    />
    <meta name="robots" content="index,follow" />
    <link rel="canonical" href="/" />
    <meta name="theme-color" content="#ffffff" />

    <!-- Open Graph / Facebook -->
    <meta property="og:site_name" content="PaperTrail" />
    <meta property="og:type" content="website" />
    <meta
      property="og:title"
      content="PaperTrail â€” map your evidence, follow the story."
    />
    <meta
      property="og:description"
      content="PaperTrail is a lightweight evidence-mapping app. Create text, image, and link nodes, connect them, auto-layout, and import/export boards."
    />
    <meta property="og:url" content="/" />
    <meta property="og:image" content="/assets/og-image.png" />
    <meta property="og:image:type" content="image/png" />
    <meta property="og:image:width" content="1200" />
    <meta property="og:image:height" content="630" />

    <!-- Twitter -->
    <meta name="twitter:card" content="summary_large_image" />
    <meta
      name="twitter:title"
      content="PaperTrail â€” map your evidence, follow the story."
    />
    <meta
      name="twitter:description"
      content="PaperTrail is a lightweight evidence-mapping app. Create text, image, and link nodes, connect them, auto-layout, and import/export boards."
    />
    <meta name="twitter:image" content="/assets/og-image.png" />
    <link rel="stylesheet" href="/css/global.css" />
    <link rel="stylesheet" href="/css/pages/papertrail.css" />
  </head>

  <body class="page page-papertrail">
    {{> sidebar}}
    <main class="page__wrap page__wrap--fullwidth">
      <div class="papertrail-header" role="toolbar">
        <div class="papertrail-header__title">
          <a class="papertrail-header__brand" href="/">PaperTrail</a>
          <div class="papertrail-header__tagline">
            map your evidence, follow the story.
          </div>
          <div
            class="papertrail-header__board-name"
            id="boardName"
            contenteditable="true"
            data-placeholder="Untitled Board"
          ></div>
        </div>
        <button
          id="addText"
          class="papertrail-header__btn papertrail-header__btn--icon"
          title="Add text"
        >
          <svg viewBox="0 0 24 24" aria-hidden="true">
            <rect x="4" y="3" width="16" height="18" rx="2" ry="2" />
            <line x1="8" y1="9" x2="16" y2="9" />
            <line x1="8" y1="13" x2="16" y2="13" />
            <line x1="8" y1="17" x2="14" y2="17" />
          </svg>
        </button>
        <button
          id="addImage"
          class="papertrail-header__btn papertrail-header__btn--icon"
          title="Add image (URL)"
        >
          <svg viewBox="0 0 24 24" aria-hidden="true">
            <rect x="3" y="5" width="18" height="14" rx="2" />
            <path d="M7 15l3-3 3 3 4-4 3 3" />
            <circle cx="9" cy="9" r="1.5" />
          </svg>
        </button>
        <button
          id="uploadImage"
          class="papertrail-header__btn papertrail-header__btn--icon"
          title="Upload image"
        >
          <svg viewBox="0 0 24 24" aria-hidden="true">
            <path d="M12 15V5" />
            <path d="M8 9l4-4 4 4" />
            <path d="M4 19h16" />
          </svg>
        </button>
        <input
          id="fileInput"
          type="file"
          accept="image/*"
          style="display: none"
        />
        <button
          id="addLink"
          class="papertrail-header__btn papertrail-header__btn--icon"
          title="Add link"
        >
          <svg viewBox="0 0 24 24" aria-hidden="true">
            <path d="M10 14l-2 2a4 4 0 0 1-6-6l2-2" />
            <path d="M14 10l2-2a4 4 0 0 1 6 6l-2 2" />
            <path d="M8 12l8-8" opacity="0.0" />
          </svg>
        </button>
        <button
          id="connect"
          class="papertrail-header__btn papertrail-header__btn--icon"
          title="Connect nodes (C)"
        >
          <svg viewBox="0 0 24 24" aria-hidden="true">
            <circle cx="6" cy="12" r="2" />
            <circle cx="18" cy="6" r="2" />
            <circle cx="18" cy="18" r="2" />
            <path d="M8 12h6" />
            <path d="M12 12L17 7" />
            <path d="M12 12l5 5" />
          </svg>
        </button>
        <div class="papertrail-header__search-wrap">
          <input
            id="search"
            class="papertrail-header__search"
            type="search"
            placeholder="Searchâ€¦ (use #tag)"
          />
          <button id="clearSearch" title="Clear search">âœ•</button>
        </div>
        <div class="toolbar__spacer"></div>
        <button
          id="autoLayout"
          class="papertrail-header__btn papertrail-header__btn--icon"
          title="Auto layout"
        >
          <svg viewBox="0 0 24 24" aria-hidden="true">
            <rect x="4" y="4" width="6" height="6" />
            <rect x="14" y="4" width="6" height="6" />
            <rect x="4" y="14" width="6" height="6" />
            <rect x="14" y="14" width="6" height="6" />
          </svg>
        </button>
        <button
          id="export"
          class="papertrail-header__btn papertrail-header__btn--icon"
          title="Export board"
        >
          <svg viewBox="0 0 24 24" aria-hidden="true">
            <path d="M12 5v10" />
            <path d="M8 9l4-4 4 4" />
            <path d="M4 19h16" />
          </svg>
        </button>
        <button
          id="importBtn"
          class="papertrail-header__btn papertrail-header__btn--icon"
          title="Import board"
        >
          <svg viewBox="0 0 24 24" aria-hidden="true">
            <path d="M12 19V9" />
            <path d="M8 15l4 4 4-4" />
            <path d="M4 5h16" />
          </svg>
        </button>
        <input
          id="importFile"
          type="file"
          accept="application/zip,application/x-zip-compressed,.zip,application/json"
          style="display: none"
        />
        {{#if is_owner}}
        <button
          id="save"
          class="papertrail-header__btn papertrail-header__btn--icon"
          disabled
          title="Save"
        >
          <svg viewBox="0 0 24 24" aria-hidden="true">
            <rect x="4" y="4" width="16" height="16" rx="2" />
            <rect x="8" y="4" width="8" height="6" />
            <rect x="9" y="14" width="6" height="6" />
          </svg>
        </button>
        {{/if}}
        <button
          id="reset"
          class="papertrail-header__btn papertrail-header__btn--icon"
          title="Reset board"
        >
          <svg viewBox="0 0 24 24" aria-hidden="true">
            <path d="M3 12a9 9 0 1 0 3-6" />
            <path d="M3 4v6h6" />
          </svg>
        </button>
        <button
          id="infoBtn"
          class="papertrail-header__btn papertrail-header__btn--icon"
          title="About / Info"
        >
          <svg viewBox="0 0 24 24" aria-hidden="true">
            <circle cx="12" cy="12" r="10" />
            <circle cx="12" cy="8" r="1.4" />
            <path d="M12 11v5" stroke-linecap="round" />
          </svg>
        </button>
        {{#if show_settings}}
        <button
          id="settingsBtn"
          class="papertrail-header__btn papertrail-header__btn--icon"
          title="Board settings"
        >
          <svg viewBox="0 0 24 24" aria-hidden="true">
            <circle cx="12" cy="12" r="3" />
            <path
              d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 1 1-2.83 2.83l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 1 1-4 0v-.09a1.65 1.65 0 0 0-1-1.51 1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 1 1-2.83-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 1 1 0-4h.09a1.65 1.65 0 0 0 1.51-1 1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 1 1 2.83-2.83l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1-1.51V3a2 2 0 1 1 4 0v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 1 1 2.83 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82V9c0 .66.26 1.3.73 1.77.47.47 1.11.73 1.77.73H21a2 2 0 1 1 0 4h-.09a1.65 1.65 0 0 0-1.51 1z"
            />
          </svg>
        </button>
        {{/if}}
        <div style="width: 32px">
          {{> userbar hide_user_name=true show_user_menu=true overrides="top-28"}}
        </div>
      </div>
      <div class="papertrail-board" id="board">
        <div id="boardSizer"></div>
        <svg id="edges"></svg>
      </div>
      <div id="ctxMenu" class="context-menu"></div>
      <div class="statusbar">
        <span id="status" class="statusbar__text"></span>
        <span class="statusbar__hint" id="modeHint"
          >ðŸ’¡ Mode: Select/Move. Press C to toggle connect mode.</span
        >
      </div>
      <div
        id="aboutModal"
        class="modal__backdrop"
        role="dialog"
        aria-modal="true"
        aria-labelledby="aboutTitle"
      >
        <div class="modal">
          <header class="modal__header">
            <h3 id="aboutTitle" class="modal__title">
              PaperTrail â€” map your evidence, follow the story
            </h3>
            <button
              type="button"
              id="aboutClose"
              class="modal__close"
              aria-label="Close"
            >
              âœ•
            </button>
          </header>
          <div class="modal__body">
            <p>
              <em>PaperTrail</em> is a lightweight visual evidence board for
              organizing ideas, documents, images, and links. It lets you pin
              down pieces of information, connect them freely, and uncover
              patterns. Whether youâ€™re researching, investigating, or just
              making sense of complex projects, PaperTrail helps you create a
              clear trail of evidence you can return to and share.
            </p>
            <p>
              At this stage, PaperTrail is designed as a single-user,
              single-workspace app. That means there is only one active board
              available at a time. Features such as real-time collaboration,
              multi-user access, or simultaneous editing are not yet supported.
            </p>
            <p>
              If you want to manage multiple boards or workspaces, you can still
              do so manually using the Import/Export features:
            </p>
            <ul>
              <li>Export your current board as a .zip file to save it.</li>
              <li>
                Import a previously exported board to continue working on it.
              </li>
              <li>
                You are responsible for organizing these exported files if you
                wish to maintain multiple workspaces.
              </li>
            </ul>
            <p>
              This setup is lightweight and simple, making it ideal for solo
              use, prototyping, or testing out ideas. Future versions of
              PaperTrail may add multi-board support and collaboration features.
            </p>
            <div class="kv">
              <div>App version</div>
              <div id="aboutAppVersion">â€”</div>
              <div>Schema version</div>
              <div id="aboutSchemaVersion">â€”</div>
              <div>Current board</div>
              <div id="aboutBoardName">â€”</div>
            </div>
          </div>
        </div>
      </div>
      <div
        id="settingsModal"
        class="modal__backdrop"
        role="dialog"
        aria-modal="true"
        aria-labelledby="settingsTitle"
      >
        <div class="modal">
          <header class="modal__header">
            <h3 id="settingsTitle" class="modal__title">Board settings</h3>
            <button
              type="button"
              id="settingsClose"
              class="modal__close"
              aria-label="Close"
            >
              âœ•
            </button>
          </header>
          <div class="modal__body">
            <p
              id="settingsNotice"
              style="
                display: none;
                margin: 10px 0px 0px;
                color: #b45309;
                background: #fff7ed;
                border: 1px solid #fde68a;
                padding: 8px 10px;
                border-radius: 8px;
              "
            >
              You can view settings on public boards, but only the owner can
              make changes.
            </p>
            <div
              style="
                display: grid;
                grid-template-columns: 140px 1fr;
                gap: 10px;
                align-items: center;
                margin-top: 15px;
              "
            >
              <label for="titleInput">Title</label>
              <input id="titleInput" type="text" />

              <label for="visibilitySelect">Visibility</label>
              <select id="visibilitySelect">
                <option value="public">Public</option>
                <option value="private">Private</option>
              </select>

              <label for="statusSelect">Status</label>
              <select id="statusSelect">
                <option value="draft">Draft</option>
                <option value="published">Published</option>
              </select>
            </div>

            <div
              style="
                display: flex;
                gap: 10px;
                justify-content: flex-end;
                margin-top: 16px;
              "
            >
              <button id="saveMetaBtn">Save changes</button>
            </div>
            {{#if is_owner}}
            <details style="margin-top: 10px">
              <summary><strong>Danger zone</strong></summary>
              <div
                style="
                  border: 1px solid #ccc;
                  margin-top: 5px;
                  padding: 10px;
                  border-radius: 0.3rem;
                "
              >
                <span style="color: #b91c1c">
                  Deleting this board is permanent. This removes nodes, edges,
                  and uploads.
                </span>
                <div
                  style="
                    display: flex;
                    gap: 10px;
                    align-items: center;
                    margin-top: 5px;
                  "
                >
                  <input
                    id="confirmIdInput"
                    type="text"
                    placeholder="Type: {{board_id}}"
                  />
                  <button id="deleteBoardBtn">Delete</button>
                </div>
              </div>
            </details>
            {{/if}}
          </div>
        </div>
      </div>
    </main>
    <script>
      // Binding for dynamic values from server
      // (injected by server-side templating)
      window.__globals = {
        appVersion: "{{app_version}}",
        schemaVersion: "{{schema_version}}",
        boardId: "{{board_id}}",
        boardTitle: "{{board_title}}",
        boardVisibility: "{{board_visibility}}",
        boardStatus: "{{board_status}}",
        isOwner: "{{is_owner}}",
      };

      // --- App State ---
      const $ = (sel) => document.querySelector(sel);
      const toolbarEl = document.querySelector(".papertrail-header");
      const boardEl = $("#board");
      const edgesSvg = $("#edges");
      const statusEl = $("#status");
      let saveBtn = document.getElementById("save");
      const exportBtn = document.getElementById("export");
      const importBtn = document.getElementById("importBtn");
      const importFile = document.getElementById("importFile");
      const searchInput = document.getElementById("search");
      const infoBtn = document.getElementById("infoBtn");
      const aboutModal = document.getElementById("aboutModal");
      const aboutClose = document.getElementById("aboutClose");
      const isOwner = String(window.__globals.isOwner) === "true";
      let lastSavedJSON = null;

      // --- Ensure DOM positions/sizes are synced to the model prior to save
      function syncDomToModel() {
        for (const n of board.nodes) {
          const el = document.getElementById(n.id);
          if (!el) continue;
          const left = Number.parseFloat(el.style.left);
          const top = Number.parseFloat(el.style.top);
          n.x = Number.isFinite(left) ? left : el.offsetLeft || n.x || 0;
          n.y = Number.isFinite(top) ? top : el.offsetTop || n.y || 0;
          // Persist measured size so edges/auto-layout remain consistent after reload
          n.w = Math.trunc(el.offsetWidth || n.w || 0) || undefined;
          n.h = Math.trunc(el.offsetHeight || n.h || 0) || undefined;
        }
      }

      // Rebind the Save button to guarantee our latest handler and avoid duplicate listeners
      function wireSaveButton() {
        if (!saveBtn) return;
        const oldBtn = document.getElementById("save");
        const newBtn = oldBtn.cloneNode(true); // drops prior listeners
        oldBtn.parentNode.replaceChild(newBtn, oldBtn);
        saveBtn = newBtn;

        newBtn.addEventListener("click", async () => {
          try {
            newBtn.disabled = true;
            // Always sync the latest DOM position/size state before snapshot + POST
            syncDomToModel();
            const payload = { ...board, id: window.__globals.boardId };
            const resp = await fetch(
              `/api/board/${encodeURIComponent(window.__globals.boardId)}`,
              {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify(payload),
              },
            );
            const data = await resp.json().catch(() => ({}));
            if (!resp.ok)
              throw new Error(data && data.error ? data.error : "Save failed");
            // Update local model with canonical server state
            board = data;
            lastSavedJSON = computeSnapshot();
            showStatus("Saved.", { ttl: 1600 });
            render();
            updateSaveButton();
          } catch (e) {
            showStatus(e && e.message ? e.message : "Save failed", {
              sticky: true,
            });
          } finally {
            updateSaveButton();
          }
        });
      }

      // Ghost edge state
      let ghostPath = null; // SVGPathElement
      let lastMouse = { x: 0, y: 0 };

      function ensureGhostPath() {
        if (!ghostPath) {
          ghostPath = document.createElementNS(
            "http://www.w3.org/2000/svg",
            "path",
          );
          ghostPath.setAttribute("class", "edge edge--ghost");
          edgesSvg.appendChild(ghostPath);
        } else if (!edgesSvg.contains(ghostPath)) {
          edgesSvg.appendChild(ghostPath);
        }
      }
      function hideGhost() {
        if (ghostPath) ghostPath.setAttribute("d", "");
      }
      function boardPointFromClient(ev) {
        const rect = boardEl.getBoundingClientRect();
        return {
          x: boardEl.scrollLeft + (ev.clientX - rect.left),
          y: boardEl.scrollTop + (ev.clientY - rect.top),
        };
      }
      function renderGhostEdge() {
        if (!connectMode || !connectFromId) {
          hideGhost();
          return;
        }
        const src = board.nodes.find((n) => n.id === connectFromId);
        if (!src) {
          hideGhost();
          return;
        }
        // Use the same smooth cubic logic as permanent edges
        const mx = lastMouse.x,
          my = lastMouse.y;
        const a1 = anchorPoint(src, mx, my);
        const a2 = mouseAnchor(src, mx, my);
        ensureGhostPath();
        ghostPath.setAttribute("d", smoothCubic(a1, a2));
      }

      function adjustBoardHeight() {
        const tb = toolbarEl ? toolbarEl.offsetHeight : 0;
        // 24px = status bar height
        boardEl.style.height = `calc(100vh - ${tb}px - 24px)`;
        updateBoardExtent();
      }
      window.addEventListener("resize", adjustBoardHeight);

      boardEl.addEventListener("mousemove", (ev) => {
        lastMouse = boardPointFromClient(ev);
        if (connectMode && connectFromId) renderGhostEdge();
      });
      // Also update when moving over the SVG layer (useful when pointer leaves node area)
      edgesSvg.addEventListener("mousemove", (ev) => {
        lastMouse = boardPointFromClient(ev);
        if (connectMode && connectFromId) renderGhostEdge();
      });

      // Unified status & mode controller
      const ui = {
        connectMode: false,
        status: { text: "", timer: null, sticky: false },
      };
      function renderStatusBar() {
        const modeText = ui.connectMode
          ? "ðŸ’¡ Mode: Connect"
          : "ðŸ’¡ Mode: Select/Move (press C to connect)";
        document.getElementById("modeHint").textContent = modeText;
        statusEl.textContent = ui.status.text || "";
      }
      function setConnectMode(on) {
        ui.connectMode = !!on;
        document.body.classList.toggle("connect-mode", ui.connectMode);
        const connectBtn = document.getElementById("connect");
        connectBtn.classList.toggle("toolbar__btn--active", ui.connectMode);

        // Disable/enable other toolbar controls
        document.querySelectorAll(".toolbar button").forEach((btn) => {
          if (btn.id === "connect") return;
          btn.disabled = ui.connectMode;
        });

        renderStatusBar();
      }

      // Show a transient status message; use {sticky:true} to persist until changed
      function showStatus(msg, opts = {}) {
        const { sticky = false, ttl = 2200 } = opts;
        // Avoid flicker: ignore if message unchanged
        if (ui.status.text === msg && ui.status.sticky === sticky) return;
        ui.status.text = msg;
        ui.status.sticky = sticky;
        statusEl.textContent = ui.status.text;
        if (ui.status.timer) {
          clearTimeout(ui.status.timer);
          ui.status.timer = null;
        }
        if (!sticky) {
          ui.status.timer = setTimeout(() => {
            ui.status.text = "";
            ui.status.sticky = false;
            renderStatusBar();
          }, ttl);
        }
      }

      // Back-compat wrappers so existing calls keep working
      function setStatus(msg) {
        showStatus(msg);
      }

      const boardNameEl = document.getElementById("boardName");

      // Keep single-line feel: prevent Enter/Return from inserting new lines
      boardNameEl.addEventListener("keydown", (e) => {
        if (e.key === "Enter") {
          e.preventDefault();
          boardNameEl.blur();
        }
      });

      // Update model on input and enable Save
      boardNameEl.addEventListener("input", () => {
        board.title = (boardNameEl.textContent || "").trim();
        markDirty();
      });

      // On blur, ensure a non-empty title for display (model can be empty if desired)
      boardNameEl.addEventListener("blur", () => {
        if (!boardNameEl.textContent || !boardNameEl.textContent.trim()) {
          boardNameEl.textContent = "Untitled Board";
        }
      });

      function isTypingTarget(el) {
        if (!el) return false;
        if (el.isContentEditable) return true;
        const tag = (el.tagName || "").toUpperCase();
        return tag === "INPUT" || tag === "TEXTAREA" || tag === "SELECT";
      }

      function stableBoardSnapshot(b) {
        // Create a deterministic snapshot that ignores volatile fields (like updatedAt)
        // and normalizes numeric values so tiny float jitter doesn't flip the Save button.
        return {
          id: b.id,
          title: b.title || "",
          visibility: b.visibility || "public",
          // Normalize nodes and only include fields that affect persistence
          nodes: (b.nodes || []).map((n) => ({
            id: n.id,
            type: n.type,
            x: Math.round(n.x || 0),
            y: Math.round(n.y || 0),
            w: Number.isFinite(n.w) ? Math.round(n.w) : undefined,
            h: Number.isFinite(n.h) ? Math.round(n.h) : undefined,
            data: n.data || {},
          })),
          // Normalize edges similarly
          edges: (b.edges || []).map((e) => ({
            id: e.id,
            sourceId: e.sourceId,
            targetId: e.targetId,
            label: e.label || undefined,
            dashed: !!e.dashed,
            color: e.color || undefined,
          })),
          createdAt: b.createdAt || undefined,
          // NOTE: updatedAt is intentionally excluded from snapshot comparison
        };
      }
      function computeSnapshot() {
        return JSON.stringify(stableBoardSnapshot(board));
      }
      function updateSaveButton() {
        if (!saveBtn) return;

        const snap = computeSnapshot();
        // On first run, capture a clean baseline so Save starts disabled,
        // and subsequent changes correctly enable the button.
        if (lastSavedJSON === null) {
          lastSavedJSON = snap;
          saveBtn.disabled = true;
          return;
        }
        saveBtn.disabled = snap === lastSavedJSON;
      }
      function markDirty() {
        // Record mutation time (not part of snapshot equivalence)
        try {
          board.updatedAt = new Date().toISOString();
        } catch (_) {}
        // Re-evaluate against the last saved snapshot so moving a node back disables Save
        updateSaveButton();
      }
      const ctxMenu = document.getElementById("ctxMenu");
      let ctxTarget = null; // { type: 'node'|'edge', id: string }

      function showContextMenu(x, y, target) {
        ctxTarget = target; // { type, id }
        const menu = ctxMenu;

        // Build menu dynamically based on target type
        if (ctxTarget && ctxTarget.type === "edge") {
          menu.innerHTML = `
            <button class="context-menu__item" data-action="label">Edit label</button>
            <button class="context-menu__item" data-action="dashed">Toggle dashed</button>
            <button class="context-menu__item" data-action="color">Set colorâ€¦</button>
            <button class="context-menu__item" data-action="delete">Delete</button>
          `;
        } else {
          const node = board.nodes.find((n) => n.id === target.id);
          if (!node) {
            menu.innerHTML = "";
          } else if (node.type === "link") {
            const canEditText = !!(
              node.data &&
              typeof node.data.descHtml === "string" &&
              node.data.descHtml.trim().length
            );
            menu.innerHTML = `
      <button class="context-menu__item" data-action="edit-link-url">Edit link URLâ€¦</button>
      ${
        canEditText
          ? '<button class="context-menu__item" data-action="edit-text">Edit textâ€¦</button>'
          : ""
      }
      <button class="context-menu__item" data-action="delete">Delete</button>
    `;
          } else if (node.type === "image") {
            const canEditText = !!(
              node.data &&
              typeof node.data.descHtml === "string" &&
              node.data.descHtml.trim().length
            );
            menu.innerHTML = `
      ${
        canEditText
          ? '<button class="context-menu__item" data-action="edit-text">Edit textâ€¦</button>'
          : ""
      }
      <button class="context-menu__item" data-action="delete">Delete</button>
    `;
          } else if (node.type === "text") {
            menu.innerHTML = `
      <button class="context-menu__item" data-action="edit-text">Edit textâ€¦</button>
      <button class="context-menu__item" data-action="delete">Delete</button>
    `;
          } else {
            menu.innerHTML = `
      <button class="context-menu__item" data-action="delete">Delete</button>
    `;
          }
        }

        menu.style.display = "block";
        // constrain within window
        const mw = menu.offsetWidth || 160;
        const mh = menu.offsetHeight || 44;
        const vw = window.innerWidth;
        const vh = window.innerHeight;
        let px = x,
          py = y;
        if (px + mw > vw) px = vw - mw - 8;
        if (py + mh > vh) py = vh - mh - 8;
        menu.style.left = px + "px";
        menu.style.top = py + "px";
      }
      function hideContextMenu() {
        ctxMenu.style.display = "none";
        ctxTarget = null;
      }

      // clicking elsewhere hides menu
      document.addEventListener("mousedown", (ev) => {
        if (ctxMenu.style.display === "block") {
          const within = ctxMenu.contains(ev.target);
          if (!within) hideContextMenu();
        }
      });

      // Esc hides menu
      document.addEventListener("keydown", (ev) => {
        if (ev.key === "Escape") hideContextMenu();
      });

      // Context menu actions (delegated)
      ctxMenu.addEventListener("click", (ev) => {
        const btn = ev.target.closest("button");
        if (!btn) return;
        const action = btn.getAttribute("data-action");
        if (!ctxTarget) {
          hideContextMenu();
          return;
        }

        if (ctxTarget.type === "node") {
          const node = board.nodes.find((n) => n.id === ctxTarget.id);
          if (!node) {
            hideContextMenu();
            return;
          }

          if (action === "edit-text") {
            const nodeEl = document.getElementById(node.id);
            if (nodeEl) {
              const rich = nodeEl.querySelector(".rich");
              if (rich) {
                // enter edit mode
                rich.setAttribute("contenteditable", "true");
                nodeEl.classList.add("node--editing");
                setTimeout(() => {
                  try {
                    placeCaretAtEnd(rich);
                  } catch (_) {}
                  rich.focus();
                }, 0);
              }
            }
            hideContextMenu();
            return;
          }

          if (action === "delete") {
            selectedNodeId = ctxTarget.id;
            selectedEdgeId = null;
            hideContextMenu();
            removeSelection();
            return;
          }

          if (action === "edit-link-url" && node.type === "link") {
            const val = prompt("Link URL:", node.data.linkUrl || "https://");
            if (val !== null) {
              const url = (val || "").trim();
              if (url) {
                node.data.linkUrl = url;
                // Invalidate previous preview so it refetches
                delete node.data.preview;
                hideContextMenu();
                markDirty();
                renderNode(node);
                renderEdges();
              }
            }
            return;
          }
          hideContextMenu();
          return;
        }

        // Edge actions
        const edge = board.edges.find((e) => e.id === ctxTarget.id);
        if (!edge) {
          hideContextMenu();
          return;
        }

        if (action === "delete") {
          selectedEdgeId = edge.id;
          selectedNodeId = null;
          hideContextMenu();
          removeSelection();
        } else if (action === "label") {
          const val = prompt("Edge label:", edge.label || "");
          if (val !== null) {
            edge.label = val.trim();
            hideContextMenu();
            markDirty();
            renderEdges();
          }
        } else if (action === "dashed") {
          edge.dashed = !edge.dashed;
          hideContextMenu();
          markDirty();
          renderEdges();
        } else if (action === "color") {
          const val = prompt(
            "Stroke color (e.g. #f87171 or red). Leave blank to reset:",
            edge.color || "",
          );
          if (val === null) return;
          const v = val.trim();
          if (v === "") delete edge.color;
          else edge.color = v;
          hideContextMenu();
          markDirty();
          renderEdges();
        }
      });

      let board = {
        id: "board-1",
        title: "My Evidence Board",
        nodes: [],
        edges: [],
        createdAt: new Date().toISOString(),
        updatedAt: new Date().toISOString(),
      };

      // Initialize board name display from default board.title
      boardNameEl.textContent = board.title || "";
      // Establish initial clean snapshot so Save enables on changes
      updateSaveButton();
      wireSaveButton();

      (async function loadInitialBoard() {
        // try {
        //   const resp = await fetch(
        //     `/api/board/${encodeURIComponent(window.__globals.boardId)}`
        //   );
        //   if (!resp.ok) throw new Error("not found");
        //   const board = await resp.json();
        //   boardNameEl.textContent = board.title;
        //   lastSavedJSON = computeSnapshot();
        //   render();
        //   updateSaveButton();
        //   wireSaveButton();
        // } catch (e) {
        //   console.error("Failed to load board:", window.__globals.boardId, e);
        //   // window.location.href = "/404.html";
        // }
      })();

      let selectedNodeId = null;
      let selectedEdgeId = null;
      let connectMode = false;
      let connectFromId = null;

      const genId = (p = "id") =>
        p + "-" + Math.random().toString(36).slice(2, 8);

      function addNode(type, at = { x: 100, y: 100 }, payload = {}) {
        const id = genId("n");
        const base = {
          id,
          type,
          x: at.x,
          y: at.y,
          w: 240,
          h: undefined,
          data: {},
        };
        if (type === "text") {
          base.data.text = payload.text ?? "New note...";
          base.data.html = escapeHtml(base.data.text);
          base.data.title = payload.title ?? "Text";
        } else if (type === "image") {
          // Ask for URL if not provided; cancel = no node
          let url = payload.imageUrl;
          if (url === undefined) {
            url = prompt("Image URL?", "");
          }
          if (url === null) return null; // user cancelled
          url = (url || "").trim();
          if (!url) return null; // empty -> abort
          base.data.imageUrl = url;
          base.data.title = payload.title ?? "Image";
          base.data.descHtml = payload.descHtml ?? ""; // optional description (rich)
        } else if (type === "link") {
          // Ask for URL if not provided; cancel = no node
          let url = payload.linkUrl;
          if (url === undefined) {
            url = prompt("Link URL?", "https://");
          }
          if (url === null) return null; // user cancelled
          url = (url || "").trim();
          if (!url) return null; // empty -> abort
          base.data.linkUrl = url;
          base.data.title = payload.title ?? "Link";
          base.data.descHtml = payload.descHtml ?? ""; // optional description (rich)
        }
        board.nodes.push(base);
        markDirty();
        render();
        return base;
      }

      function addEdge(sourceId, targetId) {
        if (!sourceId || !targetId || sourceId === targetId) return;
        const already = board.edges.find(
          (e) => e.sourceId === sourceId && e.targetId === targetId,
        );
        if (already) return;
        board.edges.push({ id: genId("e"), sourceId, targetId });
        markDirty();
        renderEdges();
      }

      function removeSelection() {
        if (selectedNodeId) {
          board.edges = board.edges.filter(
            (e) =>
              e.sourceId !== selectedNodeId && e.targetId !== selectedNodeId,
          );
          board.nodes = board.nodes.filter((n) => n.id !== selectedNodeId);
          setStatus("Node deleted.");
          selectedNodeId = null;
        } else if (selectedEdgeId) {
          board.edges = board.edges.filter((e) => e.id !== selectedEdgeId);
          setStatus("Edge deleted.");
          selectedEdgeId = null;
        }
        markDirty();
        render();
      }

      function nodeBounds(n) {
        const el = document.getElementById(n.id);
        if (el) {
          // Use live DOM position to prevent model/view drift after save
          const left =
            Number.parseFloat(el.style.left) || el.offsetLeft || n.x || 0;
          const top =
            Number.parseFloat(el.style.top) || el.offsetTop || n.y || 0;
          const w = n.w || el.offsetWidth || 200;
          const h = n.h || el.offsetHeight || 80;
          return { x: left, y: top, w, h };
        }
        // Fallback to model values if DOM element isn't mounted yet
        return {
          x: n.x,
          y: n.y,
          w: n.w || 200,
          h: n.h || 80,
        };
      }

      function centerOf(n) {
        const b = nodeBounds(n);
        return { cx: b.x + b.w / 2, cy: b.y + b.h / 2 };
      }

      function renderNode(n) {
        let el = document.getElementById(n.id);
        if (!el) {
          el = document.createElement("div");
          el.className = "node node--" + n.type;
          el.id = n.id;
          el.innerHTML = `
            <div class="node__title editable-hint" contenteditable="false" data-placeholder="Untitled"></div>
            <div class="node__content"></div>
            <div class="node__ports"><div class="node__port"></div></div>
          `;
          boardEl.appendChild(el);

          // add resize handle
          const resizer = document.createElement("div");
          resizer.className = "node__resizer";
          el.appendChild(resizer);

          let resizing = false;
          let startW = 0,
            startH = 0,
            startX = 0,
            startY = 0;
          resizer.addEventListener("mousedown", (ev) => {
            ev.stopPropagation();
            resizing = true;
            startX = ev.clientX;
            startY = ev.clientY;
            startW = el.offsetWidth;
            startH = el.offsetHeight;
            document.body.style.userSelect = "none";
          });
          window.addEventListener("mousemove", (ev) => {
            if (!resizing) return;
            const dx = ev.clientX - startX;
            const dy = ev.clientY - startY;

            const maxW = 640,
              maxH = 600;
            const baseMinW = 160,
              baseMinH = 80;

            // Desired width from drag, clamped to base min/max
            let nextW = Math.max(
              baseMinW,
              Math.min(maxW, Math.round(startW + dx)),
            );
            // Apply width first to let text wrap and images scale, then measure content height
            el.style.width = nextW + "px";
            el.style.height = "auto";

            // Content-required height (includes title, content, tags, ports, etc.)
            const contentMinH = Math.ceil(el.scrollHeight);

            // Desired height from drag, but never below content-required height
            let nextH = Math.max(
              baseMinH,
              Math.min(maxH, Math.round(startH + dy)),
            );
            nextH = Math.max(nextH, contentMinH);

            // Commit
            n.w = nextW;
            n.h = nextH;
            el.style.height = nextH + "px";

            updateBoardExtent();
            renderEdges();
          });
          window.addEventListener("mouseup", () => {
            if (!resizing) return;
            resizing = false;
            document.body.style.userSelect = "";
            markDirty();
            updateSaveButton();
          });

          // select on click
          el.addEventListener("mousedown", (ev) => {
            if (ev.target && ev.target.closest(".node__resizer")) return;
            // if connect mode, handle port click like connection
            if (connectMode) {
              if (!connectFromId) {
                connectFromId = n.id;
                showStatus("Source selected. Pick a target.", { ttl: 2200 });
                renderGhostEdge();
              } else {
                addEdge(connectFromId, n.id);
                connectFromId = null;
                hideGhost();
                showStatus("Connected.", { ttl: 1800 });
              }
              ev.stopPropagation();
              return;
            }
            selectedEdgeId = null;
            selectedNodeId = n.id;
            updateSelections();
          });
          // right-click to open context menu for this node
          el.addEventListener("contextmenu", (ev) => {
            // If right-click occurs inside an editable rich text area, allow native menu for copy/paste
            const richTarget = ev.target && ev.target.closest(".rich");
            if (
              richTarget &&
              richTarget.getAttribute("contenteditable") === "true"
            ) {
              return; // let the browser show its native menu
            }
            ev.preventDefault();
            selectedEdgeId = null;
            selectedNodeId = n.id;
            updateSelections();
            // show menu at mouse position
            showContextMenu(ev.clientX, ev.clientY, { type: "node", id: n.id });
          });
          // drag
          let dragging = false,
            offX = 0,
            offY = 0;
          el.addEventListener("mousedown", (ev) => {
            if (ev.target && ev.target.closest(".node__resizer")) return;
            dragging = true;
            offX = ev.clientX - n.x;
            offY = ev.clientY - n.y;
          });
          window.addEventListener("mousemove", (ev) => {
            if (!dragging) return;
            n.x = ev.clientX - offX;
            n.y = ev.clientY - offY;
            el.style.left = n.x + "px";
            el.style.top = n.y + "px";
            updateBoardExtent();
            renderEdges(); // update edge positions live
          });
          window.addEventListener("mouseup", () => {
            if (dragging) {
              dragging = false;
              markDirty();
              updateSaveButton();
            }
          });

          // inline edits
          const titleEl = el.querySelector(".node__title");
          titleEl.addEventListener("input", () => {
            n.data.title = titleEl.textContent || "";
            markDirty();
            updateBoardExtent();
            renderEdges(); // keep connections glued to borders as size changes
          });
          // Make title editable only after a double-click
          let _preEditTitle = null;
          function placeCaretAtEnd(node) {
            const r = document.createRange();
            r.selectNodeContents(node);
            r.collapse(false);
            const sel = window.getSelection();
            sel.removeAllRanges();
            sel.addRange(r);
          }
          titleEl.addEventListener("dblclick", (ev) => {
            ev.stopPropagation();
            _preEditTitle = titleEl.textContent;
            titleEl.setAttribute("contenteditable", "true");
            // focus at end
            setTimeout(() => {
              titleEl.focus();
              placeCaretAtEnd(titleEl);
            }, 0);
          });
          // Press Enter to commit, Esc to cancel
          titleEl.addEventListener("keydown", (ev) => {
            if (ev.key === "Enter") {
              ev.preventDefault();
              titleEl.blur();
            } else if (ev.key === "Escape") {
              ev.preventDefault();
              if (_preEditTitle != null) titleEl.textContent = _preEditTitle;
              titleEl.blur();
            }
          });
          titleEl.addEventListener("blur", () => {
            // When leaving edit mode, lock it back
            titleEl.setAttribute("contenteditable", "false");
            _preEditTitle = null;
          });
          el.addEventListener("dblclick", (ev) => {
            if (n.type === "text") {
              const rich = el.querySelector(".rich");
              const rtb = el.querySelector(".rtb");
              if (rich) {
                rich.setAttribute("contenteditable", "true");
                el.classList.add("node--editing");
                setTimeout(() => {
                  try {
                    placeCaretAtEnd(rich);
                  } catch (_) {}
                  rich.focus();
                }, 0);
                if (rtb) rtb.style.display = "";
              }
              return; // no prompt
            }

            if (n.type === "image") {
              // Only trigger URL edit when the actual image is double-clicked
              const imgEl = ev.target && ev.target.closest("img");
              if (!imgEl || !el.contains(imgEl)) return; // ignore dblclicks elsewhere in the node
              const url = prompt("Edit image URL:", n.data.imageUrl ?? "");
              if (url !== null) n.data.imageUrl = url;
              renderNode(n);
              renderEdges();
              markDirty();
              return;
            }
          });
        }

        el.style.left = n.x + "px";
        el.style.top = n.y + "px";
        if (n.w) el.style.width = n.w + "px";
        else el.style.removeProperty("width");
        if (n.h) el.style.height = n.h + "px";
        else el.style.removeProperty("height");
        el.classList.toggle("selected", selectedNodeId === n.id);
        // Ensure node type modifier class follows BEM: node--{type}
        el.classList.forEach((c) => {
          if (
            (c.startsWith("node-") || c.startsWith("node--")) &&
            c !== "node"
          ) {
            el.classList.remove(c);
          }
        });
        el.classList.add("node--" + n.type);

        const titleEl = el.querySelector(".node__title");
        titleEl.setAttribute(
          "data-placeholder",
          n.type === "text"
            ? "Text title"
            : n.type === "image"
              ? "Image title"
              : "Link title",
        );
        // Preserve existing title; allow empty to show placeholder
        titleEl.textContent =
          typeof n.data.title === "string"
            ? n.data.title
            : n.type === "text"
              ? "Text"
              : n.type === "image"
                ? "Image"
                : "Link";

        const contentEl = el.querySelector(".node__content");
        if (n.type === "text") {
          const html =
            n.data.html ?? (n.data.text ? escapeHtml(n.data.text) : "");
          contentEl.innerHTML = `
            <div class="rtb" role="toolbar" aria-label="Text formatting">
              <button data-cmd="bold" title="Bold">B</button>
              <button data-cmd="italic" title="Italic"><i>I</i></button>
              <button data-cmd="underline" title="Underline"><u>U</u></button>
              <button data-cmd="insertUnorderedList" title="Bullet list">â€¢â€¢</button>
              <button data-cmd="insertOrderedList" title="Numbered list">1.</button>
              <button data-action="link" title="Insert link">ðŸ”—</button>
              <button data-action="clear" title="Clear formatting">â¨¯</button>
            </div>
            <div class="rich" contenteditable="false" data-placeholder="Type textâ€¦">${html}</div>`;
        } else if (n.type === "image") {
          const desc = n.data.descHtml ?? "";
          contentEl.innerHTML = n.data.imageUrl
            ? `<img src="${escapeAttr(n.data.imageUrl)}" alt="">` +
              (() => {
                const hasDesc = !!(n.data.descHtml && n.data.descHtml.trim());
                const wrapDisplay = hasDesc ? "" : 'style="display:none"';
                const addBtn = hasDesc
                  ? ""
                  : `<button class="add-desc" type="button">+ Add description</button>`;
                return `
                  ${addBtn}
                  <div class="rtb" role="toolbar" aria-label="Text formatting" ${wrapDisplay}>
                    <button data-cmd="bold" title="Bold">B</button>
                    <button data-cmd="italic" title="Italic"><i>I</i></button>
                    <button data-cmd="underline" title="Underline"><u>U</u></button>
                    <button data-cmd="insertUnorderedList" title="Bullet list">â€¢â€¢</button>
                    <button data-cmd="insertOrderedList" title="Numbered list">1.</button>
                    <button data-action="link" title="Insert link">ðŸ”—</button>
                    <button data-action="clear" title="Clear formatting">â¨¯</button>
                  </div>
                  <div class="rich" contenteditable="false" data-field="descHtml" data-placeholder="Add a descriptionâ€¦" ${wrapDisplay}>${
                    n.data.descHtml ?? ""
                  }</div>
                `;
              })()
            : `<em>No image</em>`;
          // Wire up Add description toggler
          const addDescBtn = el.querySelector(".add-desc");
          if (addDescBtn) {
            addDescBtn.addEventListener("click", (ev) => {
              ev.stopPropagation();
              const rtb = el.querySelector(".rtb");
              const rich = el.querySelector('.rich[data-field="descHtml"]');
              if (rtb) rtb.style.display = "";
              if (rich) {
                rich.style.display = "";
                rich.setAttribute("contenteditable", "true");
                el.classList.add("node--editing");
                setTimeout(() => {
                  try {
                    placeCaretAtEnd(rich);
                  } catch (_) {}
                  rich.focus();
                }, 0);
              }
              addDescBtn.remove();
            });
          }
        } else if (n.type === "link") {
          const u = n.data.linkUrl ?? "";
          const desc = n.data.descHtml ?? "";
          if (!u) {
            contentEl.innerHTML = `<em>No link</em>`;
          } else if (n.data.preview) {
            const hasDesc = !!(n.data.descHtml && n.data.descHtml.trim());
            const wrapDisplay = hasDesc ? "" : 'style="display:none"';
            const addBtn = hasDesc
              ? ""
              : `<button class="add-desc" type="button">+ Add description</button>`;
            contentEl.innerHTML =
              renderLinkCard(n.data.preview, u) +
              `${addBtn}
               <div class="rtb" role="toolbar" aria-label="Text formatting" ${wrapDisplay}>
                 <button data-cmd="bold" title="Bold">B</button>
                 <button data-cmd="italic" title="Italic"><i>I</i></button>
                 <button data-cmd="underline" title="Underline"><u>U</u></button>
                 <button data-cmd="insertUnorderedList" title="Bullet list">â€¢â€¢</button>
                 <button data-cmd="insertOrderedList" title="Numbered list">1.</button>
                 <button data-action="link" title="Insert link">ðŸ”—</button>
                 <button data-action="clear" title="Clear formatting">â¨¯</button>
               </div>
               <div class="rich" contenteditable="false" data-field="descHtml" data-placeholder="Add a descriptionâ€¦" ${wrapDisplay}>${desc}</div>`;
          } else {
            // initial minimal view while loading
            const hasDesc = !!(n.data.descHtml && n.data.descHtml.trim());
            const wrapDisplay = hasDesc ? "" : 'style="display:none"';
            const addBtn = hasDesc
              ? ""
              : `<button class="add-desc" type="button">+ Add description</button>`;
            contentEl.innerHTML =
              `<a href="${escapeAttr(u)}" target="_blank" rel="noopener">${escapeHtml(u)}</a>` +
              `<div style="margin-top:6px;color:#9ca3af;font-size:12px;">Loading previewâ€¦</div>` +
              `${addBtn}
               <div class="rtb" role="toolbar" aria-label="Text formatting" ${wrapDisplay}>
                 <button data-cmd="bold" title="Bold">B</button>
                 <button data-cmd="italic" title="Italic"><i>I</i></button>
                 <button data-cmd="underline" title="Underline"><u>U</u></button>
                 <button data-cmd="insertUnorderedList" title="Bullet list">â€¢â€¢</button>
                 <button data-cmd="insertOrderedList" title="Numbered list">1.</button>
                 <button data-action="link" title="Insert link">ðŸ”—</button>
                 <button data-action="clear" title="Clear formatting">â¨¯</button>
               </div>
               <div class="rich" contenteditable="false" data-field="descHtml" data-placeholder="Add a descriptionâ€¦" ${wrapDisplay}>${desc}</div>`;
            // kick off preview fetch (once)
            (async () => {
              const p = await fetchLinkPreview(u);
              if (p) {
                n.data.preview = p;
                markDirty();
                renderNode(n);
                renderEdges();
              }
            })();
          }
          // Wire up Add description toggler for Link
          const addDescBtnL = el.querySelector(".add-desc");
          if (addDescBtnL) {
            addDescBtnL.addEventListener("click", (ev) => {
              ev.stopPropagation();
              const rtb = el.querySelector(".rtb");
              const rich = el.querySelector('.rich[data-field="descHtml"]');
              if (rtb) rtb.style.display = "";
              if (rich) {
                rich.style.display = "";
                rich.setAttribute("contenteditable", "true");
                el.classList.add("node--editing");
                setTimeout(() => {
                  try {
                    placeCaretAtEnd(rich);
                  } catch (_) {}
                  rich.focus();
                }, 0);
              }
              addDescBtnL.remove();
            });
          }
        }

        // Tags UI (common to all types)
        let tagsWrap = el.querySelector(".tags");
        if (!tagsWrap) {
          tagsWrap = document.createElement("div");
          tagsWrap.className = "tags";
          el.querySelector(".node__content").appendChild(tagsWrap);
        }
        renderTagChips(n, tagsWrap);

        let addTagBtn = el.querySelector(".add-tag");
        if (!addTagBtn) {
          addTagBtn = document.createElement("button");
          addTagBtn.className = "add-tag";
          addTagBtn.textContent = "+ tag";
          el.querySelector(".node__content").appendChild(addTagBtn);
          addTagBtn.addEventListener("click", (ev) => {
            ev.stopPropagation();
            const input = prompt("Add tags (comma separated or single #tag):");
            if (!input) return;
            const parts = input
              .split(",")
              .map((s) => normalizeTag(s))
              .filter(Boolean);
            const tags = ensureTags(n);
            for (const t of parts) {
              if (!tags.includes(t)) tags.push(t);
            }
            renderTagChips(n, tagsWrap);
            markDirty();
          });
        }
        // Attach rich text toolbar listeners (Text uses data.html; Image/Link use data.descHtml)
        {
          const rtb = el.querySelector(".rtb");
          const rich = el.querySelector(".rich");
          if (rtb && rich) {
            const field = n.type === "text" ? "html" : "descHtml";
            const isOptionalDesc =
              field === "descHtml" && (n.type === "image" || n.type === "link");

            function startEditing() {
              if (rich.getAttribute("contenteditable") === "true") return;
              rich.setAttribute("contenteditable", "true");
              el.classList.add("node--editing");
              setTimeout(() => {
                try {
                  placeCaretAtEnd(rich);
                } catch (_) {}
                rich.focus();
              }, 0);
            }
            function stopEditing() {
              if (rich.getAttribute("contenteditable") !== "true") return;
              rich.setAttribute("contenteditable", "false");
              el.classList.remove("node--editing");
            }

            function ensureAddDescButton() {
              if (!isOptionalDesc) return;
              let addBtn = el.querySelector(".add-desc");
              if (!addBtn) {
                addBtn = document.createElement("button");
                addBtn.className = "add-desc";
                addBtn.type = "button";
                addBtn.textContent = "+ Add description";
                addBtn.addEventListener("click", (ev) => {
                  ev.stopPropagation();
                  if (rtb) rtb.style.display = "";
                  if (rich) {
                    rich.style.display = "";
                    startEditing();
                  }
                  addBtn.remove();
                });
                el.querySelector(".node__content").insertBefore(addBtn, rtb);
              }
            }

            function maybeCollapseIfEmpty() {
              if (!isOptionalDesc) return;
              const plain = (rich.textContent || "").trim();
              if (!plain.length) {
                n.data.descHtml = "";
                if (rtb) rtb.style.display = "none";
                if (rich) {
                  rich.style.display = "none";
                  rich.innerHTML = "";
                }
                ensureAddDescButton();
              }
            }

            // Enter editing on double click inside the rich area
            rich.addEventListener("dblclick", (ev) => {
              ev.stopPropagation();
              startEditing();
            });

            // Keep focus and ensure editing when interacting with the toolbar
            rtb.addEventListener("mousedown", (ev) => {
              ev.preventDefault();
              startEditing();
            });
            rtb.addEventListener("click", (ev) => {
              const btn = ev.target.closest("button");
              if (!btn) return;
              const cmd = btn.getAttribute("data-cmd");
              const act = btn.getAttribute("data-action");
              startEditing();
              if (cmd) {
                document.execCommand(cmd, false, null);
                n.data[field] = rich.innerHTML;
                markDirty();
                renderEdges();
                maybeCollapseIfEmpty();
              } else if (act === "link") {
                const url = prompt("Link URL", "https://");
                if (url) document.execCommand("createLink", false, url);
                n.data[field] = rich.innerHTML;
                markDirty();
                maybeCollapseIfEmpty();
              } else if (act === "clear") {
                document.execCommand("removeFormat");
                const a = rich.querySelector("a");
                if (a) {
                  const t = document.createTextNode(a.textContent || "");
                  a.replaceWith(t);
                }
                rich.innerHTML = "";
                n.data[field] = "";
                markDirty();
                maybeCollapseIfEmpty();
              }
            });

            const syncHtml = () => {
              n.data[field] = rich.innerHTML;
              markDirty();
              maybeCollapseIfEmpty();
            };
            rich.addEventListener("input", syncHtml);
            rich.addEventListener("blur", () => {
              syncHtml();
              stopEditing();
            });
            rich.addEventListener("keydown", (ev) => {
              if (ev.key === "Escape") {
                ev.preventDefault();
                stopEditing();
                rich.blur();
              } else if (ev.key === "Enter" && !ev.shiftKey) {
                ev.preventDefault();
                syncHtml();
                stopEditing();
                rich.blur();
              }
            });
          }
        }
        // Toggle resizer visibility based on node type (text, image, link are resizable)
        const resizerEl = el.querySelector(".node__resizer");
        if (resizerEl) {
          resizerEl.style.display =
            n.type === "text" || n.type === "image" || n.type === "link"
              ? ""
              : "none";
        }
      }

      function renderNodes() {
        // Remove DOM nodes that no longer exist in data
        const ids = new Set(board.nodes.map((n) => n.id));
        document.querySelectorAll(".node").forEach((el) => {
          if (!ids.has(el.id)) el.remove();
        });
        board.nodes.forEach(renderNode);
      }

      // Compute an anchor point on the boundary of node n that faces (ox, oy)
      function anchorPoint(n, ox, oy) {
        const b = nodeBounds(n);
        const cx = b.x + b.w / 2;
        const cy = b.y + b.h / 2;
        const dx = ox - cx;
        const dy = oy - cy;

        // Choose side by dominant axis
        if (Math.abs(dx) > Math.abs(dy)) {
          // left/right
          if (dx >= 0) {
            return { x: b.x + b.w, y: cy, side: "right" };
          } else {
            return { x: b.x, y: cy, side: "left" };
          }
        } else {
          // top/bottom
          if (dy >= 0) {
            return { x: cx, y: b.y + b.h, side: "bottom" };
          } else {
            return { x: cx, y: b.y, side: "top" };
          }
        }
      }

      // Build a synthetic â€œtargetâ€ anchor at the mouse so the curve bends nicely.
      // We pick the side opposite to where the mouse is relative to the source node,
      // so control points push outward (pleasant S-curve).
      function mouseAnchor(fromNode, mx, my) {
        const b = nodeBounds(fromNode);
        const cx = b.x + (b.w || 0) / 2;
        const cy = b.y + (b.h || 0) / 2;
        const dx = mx - cx;
        const dy = my - cy;
        let side;
        if (Math.abs(dx) > Math.abs(dy)) {
          side = dx >= 0 ? "left" : "right"; // opposite of mouse horizontal side
        } else {
          side = dy >= 0 ? "top" : "bottom"; // opposite of mouse vertical side
        }
        return { x: mx, y: my, side };
      }

      // Smooth cubic path between two anchors, with curvature adaptive to distance
      function smoothCubic(a, b) {
        const x1 = a.x,
          y1 = a.y,
          x2 = b.x,
          y2 = b.y;
        const dx = Math.abs(x2 - x1);
        const dy = Math.abs(y2 - y1);
        const d = Math.max(dx, dy);
        const c = Math.min(160, Math.max(40, d * 0.6)); // curvature

        let c1x = x1,
          c1y = y1,
          c2x = x2,
          c2y = y2;

        // Push control points outward from each side
        switch (a.side) {
          case "right":
            c1x += c;
            break;
          case "left":
            c1x -= c;
            break;
          case "top":
            c1y -= c;
            break;
          case "bottom":
            c1y += c;
            break;
        }
        switch (b.side) {
          case "right":
            c2x -= c;
            break;
          case "left":
            c2x += c;
            break;
          case "top":
            c2y += c;
            break;
          case "bottom":
            c2y -= c;
            break;
        }

        return `M ${x1} ${y1} C ${c1x} ${c1y}, ${c2x} ${c2y}, ${x2} ${y2}`;
      }

      function computeContentExtent(pad = 160) {
        let maxX = 0,
          maxY = 0;
        for (const n of board.nodes) {
          const b = nodeBounds(n);
          const w = b.w || 240;
          const h = b.h || 100;
          maxX = Math.max(maxX, b.x + w);
          maxY = Math.max(maxY, b.y + h);
        }
        const rect = boardEl.getBoundingClientRect();
        const w = Math.max(maxX + pad, rect.width);
        const h = Math.max(maxY + pad, rect.height);
        return { w, h };
      }

      function updateBoardExtent() {
        const { w, h } = computeContentExtent(160);
        const sizer = document.getElementById("boardSizer");
        if (sizer) {
          sizer.style.width = w + "px";
          sizer.style.height = h + "px";
        }
        edgesSvg.setAttribute("width", w);
        edgesSvg.setAttribute("height", h);
        edgesSvg.style.width = w + "px";
        edgesSvg.style.height = h + "px";
      }

      function renderEdges() {
        edgesSvg.innerHTML = "";
        updateBoardExtent();
        if (!visibleNodeIds) {
          visibleNodeIds = new Set(board.nodes.map((n) => n.id));
        }

        for (const e of board.edges) {
          const s = board.nodes.find((n) => n.id === e.sourceId);
          const t = board.nodes.find((n) => n.id === e.targetId);
          if (!s || !t) continue;
          if (!visibleNodeIds.has(s.id) || !visibleNodeIds.has(t.id)) continue;
          const sc = centerOf(s);
          const tc = centerOf(t);
          const a1 = anchorPoint(s, tc.cx, tc.cy);
          const a2 = anchorPoint(t, sc.cx, sc.cy);
          const g = document.createElementNS("http://www.w3.org/2000/svg", "g");
          g.setAttribute("data-id", e.id);

          // Path
          const path = document.createElementNS(
            "http://www.w3.org/2000/svg",
            "path",
          );
          path.setAttribute("d", smoothCubic(a1, a2));
          let cls = "edge" + (selectedEdgeId === e.id ? " edge--selected" : "");
          if (e.dashed) cls += " edge--dashed";
          path.setAttribute("class", cls);
          if (e.color) {
            // Use inline style so it overrides the .edge CSS rule
            path.style.stroke = e.color;
          } else {
            path.style.stroke = null; // fall back to CSS (.edge { stroke: red; })
          }
          path.dataset.id = e.id;

          // Label (optional)
          if (e.label) {
            const tx = (a1.x + a2.x) / 2;
            const ty = (a1.y + a2.y) / 2 - 2; // closer to the curve
            const text = document.createElementNS(
              "http://www.w3.org/2000/svg",
              "text",
            );
            text.setAttribute("x", tx);
            text.setAttribute("y", ty);
            text.setAttribute("class", "edge__label");
            text.textContent = e.label;

            // Click/ctx on label behave like the edge
            text.addEventListener("click", (ev) => {
              selectedNodeId = null;
              selectedEdgeId = e.id;
              updateSelections();
              ev.stopPropagation();
              return false;
            });
            text.addEventListener("contextmenu", (ev) => {
              ev.preventDefault();
              ev.stopPropagation();
              selectedNodeId = null;
              selectedEdgeId = e.id;
              updateSelections();
              showContextMenu(ev.clientX, ev.clientY, {
                type: "edge",
                id: e.id,
              });
              return false;
            });
            g.appendChild(text);
          }

          // Events on path
          path.addEventListener("click", (ev) => {
            selectedNodeId = null;
            selectedEdgeId = e.id;
            updateSelections();
            ev.stopPropagation();
            return false;
          });
          path.addEventListener("contextmenu", (ev) => {
            ev.preventDefault();
            ev.stopPropagation();
            selectedNodeId = null;
            selectedEdgeId = e.id;
            updateSelections();
            showContextMenu(ev.clientX, ev.clientY, { type: "edge", id: e.id });
            return false;
          });

          g.appendChild(path);

          // Add endpoint circles
          const startCircle = document.createElementNS(
            "http://www.w3.org/2000/svg",
            "circle",
          );
          startCircle.setAttribute("cx", a1.x);
          startCircle.setAttribute("cy", a1.y);
          startCircle.setAttribute("r", "4");
          startCircle.setAttribute("class", "edge__endpoint");

          const endCircle = document.createElementNS(
            "http://www.w3.org/2000/svg",
            "circle",
          );
          endCircle.setAttribute("cx", a2.x);
          endCircle.setAttribute("cy", a2.y);
          endCircle.setAttribute("r", "4");
          endCircle.setAttribute("class", "edge__endpoint");

          g.appendChild(startCircle);
          g.appendChild(endCircle);

          edgesSvg.appendChild(g);
        }
        // Re-draw ghost on top if we're mid-connection
        if (connectMode && connectFromId) {
          renderGhostEdge();
        } else {
          hideGhost();
        }
      }

      function updateSelections() {
        // nodes
        document.querySelectorAll(".node").forEach((el) => {
          el.classList.toggle("selected", el.id === selectedNodeId);
        });
        // edges
        document.querySelectorAll("path.edge").forEach((p) => {
          p.classList.toggle("edge--selected", p.dataset.id === selectedEdgeId);
        });
      }

      function render() {
        renderNodes();
        renderEdges();
        applySearchFilter();
        adjustBoardHeight();
      }

      function escapeHtml(s) {
        return (s ?? "").toString().replace(
          /[&<>"']/g,
          (c) =>
            ({
              "&": "&amp;",
              "<": "&lt;",
              ">": "&gt;",
              '"': "&quot;",
              "'": "&#39;",
            })[c],
        );
      }
      function escapeAttr(s) {
        return escapeHtml(s);
      }

      function ensureTags(n) {
        if (!n.data) n.data = {};
        if (!Array.isArray(n.data.tags)) n.data.tags = [];
        return n.data.tags;
      }
      function normalizeTag(t) {
        return (t || "").toString().trim().replace(/^#+/, "").toLowerCase();
      }
      function renderTagChips(n, hostEl) {
        const tags = ensureTags(n);
        hostEl.innerHTML = "";
        for (let i = 0; i < tags.length; i++) {
          const tag = tags[i];
          const chip = document.createElement("span");
          chip.className = "chip";
          chip.innerHTML = `<span>#${escapeHtml(
            tag,
          )}</span> <button title="Remove tag" data-i="${i}">âœ•</button>`;
          chip.querySelector("button").addEventListener("click", (ev) => {
            ev.stopPropagation();
            tags.splice(i, 1);
            renderTagChips(n, hostEl);
            markDirty();
          });
          hostEl.appendChild(chip);
        }
      }

      function plainTextFromHtml(html) {
        const tmp = document.createElement("div");
        tmp.innerHTML = html || "";
        return (tmp.textContent || tmp.innerText || "").trim();
      }

      let currentQuery = "";
      let visibleNodeIds = null; // Set<string>

      function parseQuery(q) {
        const parts = (q || "").trim().split(/\\s+/).filter(Boolean);
        const tags = [];
        const terms = [];
        for (const p of parts) {
          if (p.startsWith("#")) tags.push(normalizeTag(p));
          else terms.push(p.toLowerCase());
        }
        return { tags, terms };
      }

      function nodeMatches(n, q) {
        if (!q || (!q.tags.length && !q.terms.length)) return true;
        const tags = ensureTags(n);
        // tag logic: all query tags must be present
        for (const t of q.tags) {
          if (!tags.map(normalizeTag).includes(t)) return false;
        }
        if (!q.terms.length) return true;
        const hay = [
          n.data?.title || "",
          n.data?.text || "",
          plainTextFromHtml(n.data?.html || ""),
          n.data?.linkUrl || "",
          tags.join(" "),
        ]
          .join(" ")
          .toLowerCase();
        return q.terms.every((term) => hay.includes(term));
      }

      function applySearchFilter() {
        const q = parseQuery(currentQuery);
        visibleNodeIds = new Set();
        for (const n of board.nodes) {
          const el = document.getElementById(n.id);
          const match = nodeMatches(n, q);
          if (el) {
            el.style.display = match ? "" : "none";
            el.classList.toggle("dim", !match && currentQuery.length > 0);
          }
          if (match) visibleNodeIds.add(n.id);
        }
        renderEdges();
      }

      function exportBoard() {
        // Let the server stream a ZIP (includes board.json and uploads/)
        showStatus("Export in progressâ€¦", { sticky: true });
        // Trigger the download
        window.location.href = `/api/board/${encodeURIComponent(window.__globals.boardId)}/export`;
        // After a short delay, update the message to guide user
        setTimeout(() => {
          showStatus(
            "Export initiated. Please check your downloads folder once it completes.",
            {
              sticky: true,
            },
          );
        }, 500);
      }

      async function fetchLinkPreview(url) {
        try {
          const resp = await fetch("/api/link-preview", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ url }),
          });
          if (!resp.ok) throw new Error("Failed");
          return await resp.json();
        } catch (e) {
          return null;
        }
      }

      function renderLinkCard(preview, href) {
        const title = escapeHtml(preview?.title || href || "Link");
        const desc = escapeHtml(preview?.description || "");
        const site = escapeHtml(
          preview?.siteName || (href ? new URL(href).hostname : ""),
        );
        const icon = preview?.icon
          ? `<img class="icon" src="${escapeAttr(preview.icon)}" alt="">`
          : "";
        const img = preview?.image
          ? `<img class="thumb" src="${escapeAttr(preview.image)}" alt="">`
          : `<div class="thumb"></div>`;
        const safeHref = escapeAttr(href || preview?.url || "#");
        return `
          <a href="${safeHref}" target="_blank" rel="noopener" class="link-card">
            ${img}
            <div class="meta">
              <div class="title">${title}</div>
              ${desc ? `<div class="desc">${desc}</div>` : ""}
              <div class="site">${icon}${site}</div>
            </div>
          </a>
        `;
      }

      function validateImported(json) {
        if (!json || typeof json !== "object")
          throw new Error("File is not a JSON object");
        if (!Array.isArray(json.nodes) || !Array.isArray(json.edges))
          throw new Error("Missing nodes/edges arrays");
        // Minimal normalization: ensure required fields exist
        json.id = json.id || "board-1";
        json.title = json.title || "Imported Board";
        json.createdAt = json.createdAt || new Date().toISOString();
        json.updatedAt = new Date().toISOString();
        json.nodes = json.nodes.map((n, i) => ({
          id: n.id || `n_imp_${i}`,
          type: n.type || "text",
          x: Number.isFinite(n.x) ? n.x : 100 + i * 20,
          y: Number.isFinite(n.y) ? n.y : 100 + i * 20,
          w: n.w,
          h: n.h,
          data: n.data || {},
        }));
        json.edges = json.edges
          .filter((e) => e && e.sourceId && e.targetId)
          .map((e, i) => ({
            id: e.id || `e_imp_${i}`,
            sourceId: e.sourceId,
            targetId: e.targetId,
          }));
        return json;
      }

      // --- Auto-layout (simple layered layout, dagre-like) ---
      function buildGraph() {
        const nodes = board.nodes.map((n) => ({ id: n.id }));
        const edges = board.edges.map((e) => ({
          from: e.sourceId,
          to: e.targetId,
        }));
        const adj = new Map();
        const indeg = new Map();
        for (const n of nodes) {
          adj.set(n.id, []);
          indeg.set(n.id, 0);
        }
        for (const e of edges) {
          if (!adj.has(e.from)) adj.set(e.from, []);
          adj.get(e.from).push(e.to);
          if (indeg.has(e.to)) indeg.set(e.to, indeg.get(e.to) + 1);
          else indeg.set(e.to, 1);
        }
        return { nodes, edges, adj, indeg };
      }

      function topoLayers() {
        const { nodes, adj, indeg } = buildGraph();
        const q = [];
        const indegCopy = new Map(indeg);
        for (const n of nodes)
          if ((indegCopy.get(n.id) || 0) === 0) q.push(n.id);
        const layers = [];
        const placed = new Set();
        // Kahn-like layering: nodes with indegree==0 form layer 0, then peel
        let current = q.slice();
        let visitedCount = 0;
        while (current.length) {
          layers.push(current);
          const next = [];
          for (const id of current) {
            placed.add(id);
            visitedCount++;
            const outs = adj.get(id) || [];
            for (const v of outs) {
              indegCopy.set(v, (indegCopy.get(v) || 0) - 1);
              if (indegCopy.get(v) === 0) next.push(v);
            }
          }
          current = next;
        }
        // Any remaining nodes are in cycles; place them in subsequent layers by a simple BFS from any unplaced
        if (visitedCount < nodes.length) {
          const rest = nodes.map((n) => n.id).filter((id) => !placed.has(id));
          // group into chunks of up to 5 per layer to avoid stacking all in one
          const chunk = 5;
          for (let i = 0; i < rest.length; i += chunk)
            layers.push(rest.slice(i, i + chunk));
        }
        return layers;
      }

      function autoLayout(direction = "LR") {
        if (!board.nodes.length) return;
        // Ensure DOM sizes are measured before layout
        renderNodes();
        // Build layered structure
        const layers = topoLayers();
        const layerGap = 180; // distance between layers
        const nodeGap = 80; // distance between nodes within a layer

        // Precompute sizes
        const size = new Map();
        for (const n of board.nodes) {
          const b = nodeBounds(n);
          size.set(n.id, { w: b.w || 240, h: b.h || 100 });
        }

        if (direction === "LR") {
          // Layers progress left-to-right; within each layer, nodes are stacked vertically
          let x = 80;
          for (const layer of layers) {
            // compute max width in this layer
            let maxW = 0;
            for (const id of layer) {
              maxW = Math.max(maxW, size.get(id)?.w || 240);
            }
            // vertical placement centered around the board's current view
            let y = 80;
            for (const id of layer) {
              const n = board.nodes.find((nn) => nn.id === id);
              if (!n) continue;
              const wh = size.get(id) || { w: 240, h: 100 };
              n.x = x;
              n.y = y;
              y += wh.h + nodeGap;
            }
            x += maxW + layerGap;
          }
        } else {
          // TB top-to-bottom
          let y = 80;
          for (const layer of layers) {
            let maxH = 0;
            for (const id of layer) {
              maxH = Math.max(maxH, size.get(id)?.h || 100);
            }
            let x = 80;
            for (const id of layer) {
              const n = board.nodes.find((nn) => nn.id === id);
              if (!n) continue;
              const wh = size.get(id) || { w: 240, h: 100 };
              n.x = x;
              n.y = y;
              x += wh.w + nodeGap;
            }
            y += maxH + layerGap;
          }
        }
        render();
        markDirty();
        setStatus("Auto-layout applied");
      }

      // Ensure status bar hint is rendered on first load
      renderStatusBar();
      adjustBoardHeight();

      function openAbout() {
        document.getElementById("aboutAppVersion").textContent =
          window.__globals.appVersion;
        document.getElementById("aboutSchemaVersion").textContent = String(
          board.schemaVersion || 1,
        );
        document.getElementById("aboutBoardName").textContent =
          board.title || "Untitled Board";
        aboutModal.classList.add("show");
      }
      function closeAbout() {
        aboutModal.classList.remove("show");
      }

      // Toolbar wiring
      $("#addText").onclick = () =>
        addNode("text", viewCenter(), { text: "New note..." });
      $("#addImage").onclick = () => addNode("image", viewCenter());
      $("#addLink").onclick = () => addNode("link", viewCenter());
      $("#connect").onclick = toggleConnectMode;
      document.getElementById("autoLayout").onclick = () => autoLayout("LR");
      exportBtn.onclick = exportBoard;
      importBtn.onclick = () => importFile.click();
      infoBtn.addEventListener("click", openAbout);
      aboutClose.addEventListener("click", closeAbout);
      aboutModal.addEventListener("click", (e) => {
        if (e.target === aboutModal) closeAbout();
      });
      document.addEventListener("keydown", (e) => {
        if (e.key === "Escape") {
          if (aboutModal.classList.contains("show")) closeAbout();
          if (connectMode && connectFromId) {
            connectFromId = null;
            hideGhost();
            showStatus("Connect cancelled");
          }
        }
      });

      boardEl.addEventListener("mousedown", (ev) => {
        if (!ev.target || ev.target === boardEl) {
          if (connectMode && connectFromId) {
            connectFromId = null;
            hideGhost();
            showStatus("Connect cancelled");
          }
        }
      });
      importFile.addEventListener("change", async (e) => {
        const file = e.target.files?.[0];
        if (!file) return;
        try {
          if (/\.zip$/i.test(file.name)) {
            // Probe first
            const probeFd = new FormData();
            probeFd.append("bundle", file);
            const probeResp = await fetch(
              `/api/board/${encodeURIComponent(window.__globals.boardId)}/validate-import`,
              {
                method: "POST",
                body: probeFd,
              },
            );
            if (!probeResp.ok)
              throw new Error(`Probe failed (${probeResp.status})`);
            const meta = await probeResp.json();

            if (meta.boardId === board.id) {
              const ok = confirm(
                `You're importing the SAME board (ID: ${meta.boardId}).\nTitle: ${
                  meta.title || "(untitled)"
                }\nReplace the current board with the imported one?`,
              );
              if (!ok) {
                setStatus("Import cancelled.");
                importFile.value = "";
                return;
              }
            }

            setStatus("Importing zipâ€¦");
            const fd = new FormData();
            fd.append("bundle", file);
            const resp = await fetch(
              `/api/board/${encodeURIComponent(window.__globals.boardId)}/import`,
              {
                method: "POST",
                body: fd,
              },
            );
            if (!resp.ok) throw new Error(`Import failed (${resp.status})`);
            const json = await resp.json();
            board = json;
            render();
            markDirty();
            setStatus(`Imported ${file.name}`);
          } else {
            const text = await file.text();
            const json = JSON.parse(text);
            const validated = validateImported(json);
            if (validated.id === board.id) {
              const ok = confirm(
                `You're importing the SAME board (ID: ${validated.id}). Replace the current board with the imported one?`,
              );
              if (!ok) {
                setStatus("Import cancelled.");
                importFile.value = "";
                return;
              }
            }
            board = validated;
            render();
            markDirty();
            setStatus(`Imported ${file.name}`);
          }
        } catch (err) {
          console.error(err);
          alert(`Import failed: ${err.message || err}`);
          setStatus("Import failed.");
        } finally {
          importFile.value = "";
        }
      });
      // Search wiring (debounced + clear)
      let searchTimer = null;
      const clearSearchBtn = document.getElementById("clearSearch");
      const updateClearBtn = () => {
        clearSearchBtn.disabled = !searchInput.value;
      };
      updateClearBtn();

      searchInput.addEventListener("input", (e) => {
        currentQuery = e.target.value || "";
        if (searchTimer) clearTimeout(searchTimer);
        searchTimer = setTimeout(() => applySearchFilter(), 150);
        updateClearBtn();
      });

      // Allow Esc to clear search without triggering global handlers
      searchInput.addEventListener("keydown", (e) => {
        if (e.key === "Escape") {
          searchInput.value = "";
          currentQuery = "";
          applySearchFilter();
          updateClearBtn();
          e.stopPropagation();
        }
      });

      // Clear button
      clearSearchBtn.addEventListener("click", () => {
        searchInput.value = "";
        currentQuery = "";
        applySearchFilter();
        updateClearBtn();
        searchInput.focus();
      });
      if (isOwner) {
        $("#save").onclick = saveBoard;
        $("#reset").onclick = resetBoard;
      }

      function viewCenter() {
        const rect = boardEl.getBoundingClientRect();
        return {
          x: boardEl.scrollLeft + rect.width / 2 - 120,
          y: boardEl.scrollTop + rect.height / 2 - 60,
        };
      }

      /** Info Button */
      function openAbout() {
        document.getElementById("aboutAppVersion").textContent =
          window.__globals.appVersion;
        document.getElementById("aboutSchemaVersion").textContent = String(
          board.schemaVersion || 1,
        );
        document.getElementById("aboutBoardName").textContent =
          board.title || "Untitled Board";
        aboutModal.classList.add("show");
      }

      function closeAbout() {
        aboutModal.classList.remove("show");
      }

      infoBtn.addEventListener("click", openAbout);
      aboutClose.addEventListener("click", closeAbout);
      // Close when clicking the backdrop
      aboutModal.addEventListener("click", (e) => {
        if (e.target === aboutModal) closeAbout();
      });
      // Close on Esc
      document.addEventListener("keydown", (e) => {
        if (e.key === "Escape" && aboutModal.classList.contains("show"))
          closeAbout();
      });

      // Settings modal wiring (always visible; non-owners see read-only UI)
      {
        const settingsBtn = document.getElementById("settingsBtn");
        const settingsModal = document.getElementById("settingsModal");
        const settingsClose = document.getElementById("settingsClose");
        const visibilitySelect = document.getElementById("visibilitySelect");
        const statusSelect = document.getElementById("statusSelect");
        const titleInput = document.getElementById("titleInput");
        const saveMetaBtn = document.getElementById("saveMetaBtn");
        const deleteBoardBtn = document.getElementById("deleteBoardBtn");
        const confirmIdInput = document.getElementById("confirmIdInput");
        const settingsNotice = document.getElementById("settingsNotice");

        function openSettings() {
          // initialize values from server-globals and from current UI
          titleInput.value =
            window.__globals.boardTitle ||
            document.getElementById("boardName").textContent ||
            "";
          visibilitySelect.value = (
            window.__globals.boardVisibility || "public"
          ).toLowerCase();
          statusSelect.value = (
            window.__globals.boardStatus || "draft"
          ).toLowerCase();
          settingsModal.classList.add("show");
        }
        function closeSettings() {
          settingsModal.classList.remove("show");
        }
        // Disable controls for non-owners
        if (!isOwner) {
          settingsNotice.style.display = "block";
          titleInput.setAttribute("readonly", "true");
          titleInput.setAttribute("disabled", "true");
          visibilitySelect.setAttribute("disabled", "true");
          statusSelect.setAttribute("disabled", "true");
          saveMetaBtn.setAttribute("disabled", "true");
          if (deleteBoardBtn) {
            deleteBoardBtn.setAttribute("disabled", "true");
            deleteBoardBtn.style.opacity = "0.6";
            deleteBoardBtn.style.cursor = "not-allowed";
          }
        }

        settingsBtn?.addEventListener("click", openSettings);
        settingsClose?.addEventListener("click", closeSettings);
        settingsModal?.addEventListener("click", (e) => {
          if (e.target === settingsModal) closeSettings();
        });

        saveMetaBtn?.addEventListener("click", async () => {
          try {
            const payload = {
              visibility: visibilitySelect.value,
              status: statusSelect.value,
              title: titleInput.value,
            };
            const resp = await fetch(
              `/api/board/${encodeURIComponent(window.__globals.boardId)}/meta`,
              {
                method: "PATCH",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify(payload),
              },
            );
            const data = await resp.json().catch(() => ({}));
            if (!resp.ok) throw new Error(data?.error || "Update failed");
            // Reflect immediately in UI and local state
            const newTitle = data.title || titleInput.value;
            document.getElementById("boardName").textContent = newTitle;
            if (typeof board === "object") board.title = newTitle;
            window.__globals.boardTitle = newTitle;
            if (data.visibility)
              window.__globals.boardVisibility = data.visibility;
            if (data.status) window.__globals.boardStatus = data.status;
            // Keep settings button visible for owners regardless of visibility
            closeSettings();
            showStatus("Settings updated", { ttl: 1500 });
          } catch (e) {
            showStatus(e.message || "Update failed", { sticky: true });
          }
        });

        deleteBoardBtn?.addEventListener("click", async () => {
          if (!isOwner) {
            showStatus("Only the owner can delete this board.", {
              sticky: true,
            });
            return;
          }
          const confirmId = (confirmIdInput?.value || "").trim();
          if (confirmId !== window.__globals.boardId) {
            alert("Type the exact board id to confirm deletion.");
            return;
          }
          if (
            !confirm(
              "This will permanently delete the board and its data. Continue?",
            )
          )
            return;
          try {
            const resp = await fetch(
              `/api/board/${encodeURIComponent(window.__globals.boardId)}`,
              {
                method: "DELETE",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify({ confirm: true, confirmId }),
              },
            );
            const data = await resp.json().catch(() => ({}));
            if (!resp.ok) throw new Error(data?.error || "Delete failed");
            window.location.href = "/";
          } catch (e) {
            showStatus(e.message || "Delete failed", { sticky: true });
          }
        });
      }
      /** end of Info Button */

      function toggleConnectMode() {
        connectMode = !connectMode;
        connectFromId = null;
        setConnectMode(connectMode);
      }

      document.addEventListener("keydown", (e) => {
        const typing = isTypingTarget(e.target);

        if (!typing && (e.key === "Delete" || e.key === "Backspace")) {
          e.preventDefault(); // avoid browser back
          removeSelection();
          return;
        }
        if (!typing && e.key.toLowerCase() === "c") {
          toggleConnectMode();
          return;
        }
        if (e.key.toLowerCase() === "l" && (e.metaKey || e.ctrlKey)) {
          e.preventDefault();
          autoLayout("LR");
        }
      });

      // click blank space to clear selection
      boardEl.addEventListener("mousedown", (ev) => {
        if (ev.target === boardEl || ev.target === edgesSvg) {
          hideContextMenu();
          selectedNodeId = null;
          selectedEdgeId = null;
          updateSelections();
        }
      });
      // Allow dropping a .json file onto the board to import
      boardEl.addEventListener("dragover", (e) => {
        e.preventDefault();
      });
      boardEl.addEventListener("drop", async (e) => {
        e.preventDefault();
        const file = e.dataTransfer?.files?.[0];
        if (!file || !file.name.toLowerCase().endsWith(".json")) return;
        try {
          const text = await file.text();
          const json = JSON.parse(text);
          const validated = validateImported(json);
          board = validated;
          render();
          markDirty();
          setStatus(`Imported ${file.name}`);
        } catch (err) {
          console.error(err);
          alert(`Import failed: ${err.message || err}`);
          setStatus("Import failed.");
        }
      });

      // Load existing board
      async function loadBoard() {
        // try {
        //   const resp = await fetch(
        //     `/api/board/${encodeURIComponent(window.__globals.boardId)}`
        //   );
        //   const data = await resp.json();
        //   board = data;
        //   render();
        //   boardNameEl.textContent = board.title || "";
        //   lastSavedJSON = computeSnapshot();
        //   updateSaveButton();
        //   currentQuery = searchInput.value || "";
        //   applySearchFilter();
        //   setStatus("Loaded.");
        //   renderStatusBar();
        // } catch (e) {
        //   setStatus("No saved board yet. Start adding nodes.");
        //   renderStatusBar();
        // } finally {
        //   adjustBoardHeight();
        // }
      }

      async function saveBoard() {
        if (!saveBtn) return;

        saveBtn.disabled = true;
        setStatus("Savingâ€¦");
        try {
          const resp = await fetch(
            `/api/board/${encodeURIComponent(window.__globals.boardId)}`,
            {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify(board),
            },
          );
          const data = await resp.json();
          board = data;
          boardNameEl.textContent = board.title || "";
          lastSavedJSON = computeSnapshot();
          updateSaveButton();
          setStatus(
            "Saved at " + new Date(board.updatedAt).toLocaleTimeString(),
          );
        } catch (e) {
          saveBtn.disabled = false;
          setStatus("Save failed.");
          console.error(e);
        }
      }

      function resetBoard() {
        if (
          !confirm("Clear all nodes/edges? This will NOT save automatically.")
        )
          return;
        const now = new Date().toISOString();
        board = {
          id: board.id || "board-1",
          title: "My Evidence Board",
          nodes: [],
          edges: [],
          createdAt: board.createdAt || now,
          updatedAt: now,
        };
        boardNameEl.textContent = board.title || "";
        render();
        // Mark as dirty so user can decide to Save manually
        markDirty();
        setStatus("Board reset. Click Save to persist.");
      }

      // Image upload handling
      const fileInputEl = document.getElementById("fileInput");
      const uploadBtnEl = document.getElementById("uploadImage");

      uploadBtnEl.onclick = () => fileInputEl.click();

      fileInputEl.addEventListener("change", async (e) => {
        const file = e.target.files?.[0];
        if (!file) return;
        try {
          setStatus("Uploadingâ€¦");
          const fd = new FormData();
          fd.append("image", file);
          const res = await fetch(
            `/api/board/${encodeURIComponent(window.__globals.boardId)}/upload-image`,
            {
              method: "POST",
              body: fd,
            },
          );
          if (!res.ok) throw new Error("Upload failed");
          const data = await res.json();
          addNode("image", viewCenter(), {
            imageUrl: data.url,
            title: file.name,
          });
          markDirty();
          setStatus("Uploaded.");
        } catch (err) {
          console.error(err);
          alert(err.message || "Upload failed");
          setStatus("Upload failed.");
        } finally {
          fileInputEl.value = "";
        }
      });
      // End of image upload handling

      loadBoard();
    </script>
  </body>
</html>
